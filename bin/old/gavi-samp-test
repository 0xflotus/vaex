#!/usr/bin/env python
# -*- coding: utf-8 -*-
import numpy as np
import h5py
from optparse import OptionParser
import os
import sys
import astropy.io.votable
import thread
import threading
import time
import itertools

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbarQt
from matplotlib.figure import Figure
import matplotlib
from matplotlib.widgets import Lasso, LassoSelector
import matplotlib.widgets 
import vaex.selection
import vaex.kld
import vaex.utils

import subspacefind
import ctypes
import numexpr as ne

if 0:
	N = 1e9
	array = np.arange(N)
	counts = np.zeros(10, dtype=np.float64)
	if 0:
		#ptr = array.ctypes.data_as(ctypes.POINTER(ctypes.c_float))
		col_a = subspacefind.make_column(array)
		#col_b = subspacefind.make_column(array)
		col_b = subspacefind.SquareColumn(col_a)
		col_b2 = subspacefind.SquareColumn(col_b)
		col_b3 = subspacefind.SquareColumn(col_b2)
		col_b4 = subspacefind.SquareColumn(col_b3)
		col_c = subspacefind.DivConstColumn(col_b4, N**2)

		print col_a.get(10)
		#array[:] = array**2/N**2
		print col_a.get(10)
		print col_c.get(10)
		print sum(counts)

		with vaex.utils.Timer("hist"):
			subspacefind.histogram1d(col_c, counts, 0., 1.)
	else:
		step = 1000
		res = array[:len(array)/step] * 0.0
		Nstep = len(res)
		col_c = subspacefind.make_column(res)
		#ne.set_num_threads(10)
		vmax = None
		with vaex.utils.Timer("hist"):
			for i in range(step):
				a = array[i*Nstep:(i+1)*Nstep]
				#ne.evaluate("log(a)**2/N**2", out=res)
				ne.evaluate("sqrt(a**2+a**3)", out=res)
				if vmax is None:
					vmax = res.max()
				else:
					vmax = max(vmax, res.max())
				subspacefind.histogram1d(col_c, counts, 0., 1.)
		print  vmax
	print counts
	#col_a = subspacefind.DoubleColumn(array)
	sys.exit(0)

class NavigationToolbar(NavigationToolbarQt):
	def __init__(self, canvas, axes, parent):
		self.toolitems = [k for k in self.toolitems if (k[0] is None) or (k[0].lower() in "home pan zoom")]
		#self.toolitems.append()
		super(NavigationToolbar, self).__init__(canvas, parent)
		self.parent = parent
		self.axes = axes
		#self.basedir = os.path.join(matplotlib.rcParams[ 'datapath' ],'images')
		#print self.basedir
		self.extra_toolitems = [
			('Select', 'Select point', 'filesave', 'select_point'),
			('Lasso', 'Lasso select', 'matplotlib', 'select_lasso'),
						  ]
		for text, tooltip_text, image_file, callback in self.extra_toolitems:
			a = self.addAction(self._icon(image_file + '.png'), text, getattr(self, callback))
			a.setCheckable(True)
			self._actions[callback] = a
			if tooltip_text is not None:
				a.setToolTip(tooltip_text)
		self._idPress = None
		self._idRelease = None
		self.lasso = None
		
	def sync_buttons(self):
		self._actions['select_point'].setChecked(self._active == 'SELECT_POINT')
		self._actions['select_lasso'].setChecked(self._active == 'SELECT_LASSO')

	def select_point(self, *args):
		print self._active
		name = 'SELECT_POINT'
		self._active = None if self._active == name else name
		self.sync_buttons()
		if self._idPress is not None:
			self._idPress = self.canvas.mpl_disconnect(self._idPress)
			self._idRelease = self.canvas.mpl_disconnect(self._idRelease)

		if self.lasso:
			self.lasso.active = False
			self.lasso.disconnect_events()
			self.lasso = None
			
		if self._active == name:
			self._idPress = self.canvas.mpl_connect(
                'button_press_event', self.parent.press_select_point)
			self.canvas.widgetlock(self)
			self.set_message('select point')
		else:
			self.canvas.widgetlock.release(self)
			self.set_message('')
	
	def select_lasso(self, *args):
		print self._active
		name = 'SELECT_LASSO'
		self._active = None if self._active == name else name
		self.sync_buttons()
		if self._idPress is not None:
			self._idPress = self.canvas.mpl_disconnect(self._idPress)
			self._idRelease = self.canvas.mpl_disconnect(self._idRelease)
            
		if self._active == name:
			#self._idPress = self.canvas.mpl_connect('button_press_event', self.press_select_lasso)
			#self._idPress = self.canvas.mpl_connect('button_release_event', self.release_select_lasso)
			#self.canvas.widgetlock(self)
			#self.lasso = LassoSelector(evt.inaxes, (evt.xdata, evt.ydata), self.lasso_callback)
			self.lasso = LassoSelector(self.axes, self.lasso_callback)
			self.canvas.draw()
			self.set_message('lasso select point')
		else:
			#self.canvas.widgetlock.release(self)
			#self.set_message('')
			self.lasso.active = False
			self.lasso.disconnect_events()
			self.lasso = None

	def press_select_lasso(self, evt):
		print "lasso", self.canvas.widgetlock.locked()
		self.canvas.draw()
		if not self.canvas.widgetlock.locked():
			self.canvas.widgetlock(self.lasso)

	def release_select_lasso(self, evt):
		if self.lasso:
			self.canvas.widgetlock.release(self.lasso)
			self.lasso = None
		self.canvas.draw()
			
		
	def lasso_callback(self, vertices):
		#print vertices
		x, y = np.array(vertices).T
		mask = np.zeros(len(self.parent.datax), dtype=np.uint8)
		meanx = x.mean()
		meany = y.mean()
		radius = np.sqrt((meanx-x)**2 + (meany-y)**2).max()
		#print (x, y, self.parent.datax, self.parent.datay, mask, meanx, meany, radius)
		vaex.selection.pnpoly(x, y, self.parent.datax, self.parent.datay, mask, meanx, meany, radius)
		self.parent._set_mask(mask==1)
	
#from PySide import QtGui, QtCore
try:
	from PyQt4 import QtGui, QtCore
	import sip
	sip.setapi('QVariant', 1)
except ImportError, e1:
	try:
		from PySide import QtGui, QtCore
	except ImportError, e2:
		print >>sys.stderr, "could not import PyQt4 or PySide, please install"
		print >>sys.stderr, "errors: ", repr(e1), repr(e2)
		sys.exit(1)
	

from vaex.samp import Samp

usage = """
Convert VO table from SAMP to hdf5 format:

Example:

vaex-data-samp2hdf5 -o photometry.hdf5

Now open topcat:
topcat -f csv $vaex_DATA/scl_photo.csv

...

"""
parser = OptionParser(usage=usage)

#parser.add_option("-n", "--name",
 #                 help="dataset name [default=%default]", default="data", type=str)
#parser.add_option("-o", "--output",
#                 help="dataset output filename [by default the suffix of input filename will be replaced by hdf5]", default=None, type=str)
(options, args) = parser.parse_args()

#if len(args) != 1:
#	print "Program requires output filename as argument"
#	sys.exit(1)


import h5py
import mmap

def error(title, msg):
	print "Error", title, msg

from vaex.dataset import *
		
possibleFractions = [10**base * f for base in [-3,-2,-1,0] for f in [0.25, 0.5, 0.75, 1.]]
possibleFractions.insert(0,10**-4)
print possibleFractions

class DataList(QtGui.QListWidget):
	def __init__(self, parent):
		super(DataList, self).__init__(parent)
		self.icon = QtGui.QIcon('icons/png/24x24/devices/memory.png')
		#self.items 
		
	def testfill(self):
		self.addHdf5("/home/data/vaex/gaussian3d-1e8-b.hdf5")
		self.addHdf5("/home/data/vaex/gaussian3d-1e9-b.hdf5")
		self.addHdf5("/home/data/vaex/rave/rave-dr5-shuffled.hdf5")
		self.addHdf5("/home/data/vaex/helmi2000-FeH-s2.hdf5")
		
		#self.addGadgetHdf5("/Users/users/breddels/mab/models/nbody/gcsink/gadget/sink_nfw_soft/output/snapshot_213.hdf5")
		#self.addGadgetHdf5("/Users/users/breddels/mab/models/nbody/gcsink/gadget/sink_einasto_2kpc_fornax/IC.hdf5")
		#self.addGadgetHdf5("/Users/users/breddels/mab/models/nbody/hernquist/gadget/hernquist_half/output/snapshot_000.hdf5")
		
		self.addHdf5("/Users/maartenbreddels/vaex/src/SubspaceFinding/data/gaussian4d-1e7.hdf5")
		self.addHdf5("/Users/maartenbreddels/vaex/src/SubspaceFinding/data/helmi2000-FeH-s2.hdf5")
		
		#self.addGadget2("/home/data/vaex/egpbos/snap_008")
		self.addHdf5("/Users/users/breddels/vaex/src/SubspaceFinding/data/helmi2000-FeH-s2-shuffled.hdf5")
		
		try:
			hmmap = HansMemoryMapped("data/Orbitorb9.ac8.10000.100.5.orb.bin", "data/Orbitorb9.ac8.10000.100.5.orb.omega2")
			self.addDataset(hmmap)
		except:
			print "oops"
		self.addHdf5('/home/data/vaex/Aq-A-2-999-shuffled.hdf5')
		
		#self.addGadgetHdf5('/home/data/vaex/snap_800.hdf5')
		# 0 - gas
		# 1 - halo
		# 2 disk
		# 4 new stars
		# 5 sat
		
		for index, name in list(enumerate("gas halo disk stars sat".split()))[::-1]:
			self.addGadgetHdf5('/home/data/vaex/disk2nv_N6N5_z0.1h_RfAs0.5H_no_H1_0.5_nH01_vw5s_ml50_st-snap_800.hdf5', name, index)
		for index, name in list(enumerate("gas halo disk stars sat".split()))[::-1]:
			self.addGadgetHdf5('/home/data/vaex/oldplanar_c15_md0.002_z0.1h_H4_0.5_nH01_vw5s_ml30_sM2e9-snap_400.hdf5', name, index)
		
	def setBestFraction(self, dataset):
		Nmax = 1000*1000*10
		for fraction in possibleFractions[::-1]:
			N  = dataset.current_slice[1] - dataset.current_slice[0]
			if N > Nmax:
				dataset.setFraction(fraction)
			else:
				break
			

	def addDataset(self, dataset):
		self.setBestFraction(dataset)
		item = QtGui.QListWidgetItem(self)
		item.setText(dataset.name)
		#self.icon = QIcon.fromTheme('document-open')
		item.setIcon(self.icon)
		item.setToolTip("file: " +dataset.filename)
		item.setData(QtCore.Qt.UserRole, dataset)
		self.setCurrentItem(item)

	def addGadget2(self, filename):
		if not os.path.exists(filename):
			return
			
		self.hdf5file = MemoryMappedGadget(filename)
		self.setBestFraction(self.hdf5file)
		item = QtGui.QListWidgetItem(self)
		item.setText(self.hdf5file.name)
		item.setToolTip("file: " +self.hdf5file.filename)
		#self.icon = QIcon.fromTheme('document-open')
		item.setIcon(self.icon)
		item.setData(QtCore.Qt.UserRole, self.hdf5file)
		self.setCurrentItem(item)
			
		
	
	def addGadgetHdf5(self, filename, name, particleType):
		if not os.path.exists(filename):
			return
		try:
			self.hdf5file = Hdf5MemoryMappedGadget(filename, name, particleType)
		except KeyError:
			return
		self.setBestFraction(self.hdf5file)
		item = QtGui.QListWidgetItem(self)
		item.setText(self.hdf5file.name)
		#self.icon = QIcon.fromTheme('document-open')
		item.setToolTip("file: " +self.hdf5file.filename)
		item.setIcon(self.icon)
		item.setData(QtCore.Qt.UserRole, self.hdf5file)
		self.setCurrentItem(item)
	
	def addHdf5(self, filename):
		if not os.path.exists(filename):
			return
		
		self.hdf5file = Hdf5MemoryMapped(filename)
		self.setBestFraction(self.hdf5file)
		item = QtGui.QListWidgetItem(self)
		item.setText(self.hdf5file.name)
		item.setToolTip("file: " +self.hdf5file.filename)
		#self.icon = QIcon.fromTheme('document-open')
		item.setIcon(self.icon)
		item.setData(QtCore.Qt.UserRole, self.hdf5file)
		self.setCurrentItem(item)
		#self.setCurrentRow(0)
		
	def _addHdf5(filename, columns):
		h5file = h5py.File(filename)
		
		
		print f
		print fileno
		mapping = mmap.mmap(fileno, 0, prot=mmap.PROT_READ)
		

class Worker(QtCore.QThread):
	def __init__(self, parent, name, func, *args, **kwargs):
		QtCore.QThread.__init__(self, parent=None)
		self.func = func
		self.args = args
		self.kwargs = kwargs
		self.name = name
		self.signal = QtCore.SIGNAL("signal")
	
	def run(self):
		time.sleep(0.1)
		print "in thread", self.currentThreadId()
		self.result = self.func(*self.args, **self.kwargs)
		print "result:", self.result
		#self.emit(self.signal, self.result)
		#self.exec_()
import multiprocessing

def MyStats(object):
	def __init__(self, data):
		self.data = data
		
	def __call___(self, args):
		print args
		#stat_name, column_name = args
		#print "do", stat_name, "on", column_name
		return 1
		#f = stats[stat_name]
		#return column_name, stat_name, f(self.data.columns[column_name])

#stats = {"minimum": lambda x: str(np.nanmin(x)), "maximum": lambda x: str(np.nanmax(x)), "mean": lambda x: str(np.mean(x)), "std": lambda x: str(np.std(x)), "median": lambda x: str(np.median(x))}
stats = {"minimum": lambda x: str(np.nanmin(x)), "maximum": lambda x: str(np.nanmax(x)), "mean": lambda x: str(np.mean(x)), "std": lambda x: str(np.std(x))}
def statsrun(args):
	columns, stat_name, column_name = args
	f = stats[stat_name]
	#print args
	return 1

class StatWorker(QtCore.QThread):
	def __init__(self, parent, data):
		QtCore.QThread.__init__(self, parent=parent)
		self.data = data

	def run(self):
		time.sleep(0.1)
		print "in thread", self.currentThreadId()
		jobs = [(stat_name, column_name) for stat_name in stats.keys() for column_name in self.data.columns.keys()]
		@parallelize(cores=QtCore.QThread.idealThreadCount())
		def dostats(args, data=self.data):
			stat_name, column_name = args
			columns = data.columns
			f = stats[stat_name]
			result = f(columns[column_name][slice(*data.current_slice)])
			print result
			return result
		values = dostats(jobs)
		self.results = {}
		for job, value in zip(jobs, values):
			stat_name, column_name = job
			if stat_name not in self.results:
				self.results[stat_name] = {}
			self.results[stat_name][column_name] = value
		print "results", self.results
		
		
		

from mab.parallelize import parallelize
        
       
class StatisticsDialog(QtGui.QDialog):
	def __init__(self, parent, data):
		super(StatisticsDialog, self).__init__(parent)
		self.data = data
		
		#self.form_layout = QtGui.QFormLayout()
		#self.min = QtGui.QLabel('...computing...', self)
		#self.form_layout.addRow('Minimum:', self.min)
		#self.setLayout(self.form_layout)
		
		self.boxlist = QtGui.QHBoxLayout(self)
		
		self.headers = ['minimum', 'maximum', 'mean', 'std']
		
		#WorkerMinimum = lambda parent, data, column_name: Worker(parent, 'minimum', lambda data, column_name: str(min(data.columns[column_name])), data=data, column_name=column_name)
		#WorkerMaximum = lambda parent, data, column_name: Worker(parent, 'maximum', lambda data, column_name: str(max(data.columns[column_name])), data=data, column_name=column_name)
		#self.workers = {'minimum':WorkerMinimum, 'maximum': WorkerMaximum}
		
		self.table = QtGui.QTableWidget(data.nColumns, len(self.headers), self)
		self.table.setHorizontalHeaderLabels(self.headers)
		self.table.setVerticalHeaderLabels(self.data.columns.keys())
		
		
		
		
		#pool = multiprocessing.Pool() #processes=QtCore.QThread.idealThreadCount())
		#print "jobs:", jobs
		worker = StatWorker(self, self.data)
		def onFinish(worker=worker):
			for column, stat in enumerate(self.headers):
				for row, column_name in enumerate(self.data.columns.keys()):
					value = worker.results[stat][column_name]
					item = QtGui.QTableWidgetItem(value)
					self.table.setItem(row, column, item)
					
			
		worker.finished.connect(onFinish)
		worker.start()
		#for name in self.header:
		#for column_name in self.data.colums.keys():
		#	self.table.set
		#worker.finished.connect(onFinish)
		if 0:
			self.worker_list = [] # keep references
			def onFinish():
				for column, stat in enumerate(self.headers):
					for row, column_name in enumerate(self.data.columns.keys()):
						value = worker.results[stat][column_name]
						item = QtGui.QTableWidgetItem(worker.result)
						self.table.setItem(row, column, item)
			for column, stat in enumerate(self.headers):
				for row, column_name in enumerate(self.data.columns.keys()):
					worker = self.workers[stat](parent, data, column_name)
					def onFinish(worker=worker, row=row, column=column):
						print "finished running", worker.result
						item = QtGui.QTableWidgetItem(worker.result)
						self.table.setItem(row, column, item)
					worker.finished.connect(onFinish)
					print "starting", row, column
					worker.start(QtCore.QThread.IdlePriority)
					self.worker_list.append(worker) # keeps reference to avoid GC
		
		
		self.boxlist.addWidget(self.table)
		self.setLayout(self.boxlist)
		
		
		
		
		if 0:
			#w1 = Worker(self, lambda data: str(min(data.columns.items()[0])), self.data)
			self.w1 = Worker(self, self.test, self.data)
			#self.connect(self.w1, self.w1.signal, self.setmin)
			def setmin():
				print self.min.setText(self.w1.result)
			self.w1.finished.connect(setmin)
			self.w1.start()

	def test(self, data):
		print "test"
		data = data.columns.values()[0]
		return str(min(data))
		#return "test"
	def onFinish(self, worker):
		print "worker", worker
		#print "setting", result
		#self.min = str

import 	operator
import random
class RankingTableModel(QtCore.QAbstractTableModel): 
	def __init__(self, data, dim=1, parent=None, *args): 
		QtCore.QAbstractTableModel.__init__(self, parent, *args) 
		self.data = data
		
		self.pairs = list(itertools.combinations(self.data.column_names, dim))
		self.ranking = [None for pair in self.pairs]
		self.headers = ["subspace", "ranking", 'selected']
		self.indices = range(len(self.pairs))
	
	def rowCount(self, parent): 
		return len(self.pairs)

	def columnCount(self, parent): 
		return len(self.headers)

	def data(self, index, role): 
		if not index.isValid(): 
			return None
		elif role != QtCore.Qt.DisplayRole: 
			return None
		column = index.column()
		index = self.indices[index.row()] # use sorted index
		if column == 0:
			return "-vs".join(self.pairs[index])
		if column == 1:
			rank = self.ranking[index]
			return "" if rank is None else str(rank)
		if column == 2:
			rank = self.ranking[index]
			return False if random.random() < 0.5 else True

	def headerData(self, index, orientation, role):
		if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
			return self.headers[index]
		if orientation == QtCore.Qt.Vertical and role == QtCore.Qt.DisplayRole:
			return str(index+1)
		return None

	def sort(self, Ncol, order):
		"""Sort table by given column number.
		"""
		self.emit(QtCore.SIGNAL("layoutAboutToBeChanged()"))
		if Ncol == 0:
			print "by name"
			# get indices, sorted by pair name
			sortlist = zip(self.pairs, range(len(self.pairs)))
			print sortlist
			sortlist.sort(key=operator.itemgetter(0))
			print sortlist
			self.indices = map(operator.itemgetter(1), sortlist)
			print self.indices
		if Ncol == 1:
			# get indices, sorted by ranking, or no sorting
			if None not in self.ranking:
				sortlist = zip(self.ranking, range(len(self.pairs)))
				sortlist.sort(key=operator.itemgetter(0))
				self.indices = map(operator.itemgetter(1), sortlist)
			else:
				self.indices = range(len(self.pairs))
			print self.indices
		if order == QtCore.Qt.DescendingOrder:
			self.indices.reverse()
		print self.indices
		self.emit(QtCore.SIGNAL("layoutChanged()"))

class SubspaceTable(QtGui.QTableWidget):
	def __init__(self, parent, mainPanel, data, pairs, dim=1):
		self.headers = ['', 'space', 'ranking', 'plot']
		self.data = data
		self.mainPanel = mainPanel
		self.pairs = pairs #list(itertools.combinations(self.data.column_names, dim))
		QtGui.QTableWidget.__init__(self, len(self.pairs), len(self.headers), parent)
		self.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows);
		#self.tableModel = RankingTableModel(self.data, dim, parent)
		#self.setModel(self.tableModel)
		#self.sortByColumn(0, QtCore.Qt.AscendingOrder)
		#self.setSortingEnabled(True)
		#self.pair_to_item = {}
		self.defaultFlags = QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEnabled
		if 1:
			#self.ranking = [None for pair in self.pairs]
			self.dim = dim
			self.setHorizontalHeaderLabels(self.headers)
			self.setVerticalHeaderLabels(map(str, range(len(self.pairs))))
			self.checkboxes = []
			for i in range(len(self.pairs)):
				pair = self.pairs[i]
				text = " ".join(map(str, self.pairs[i]))
				item = QtGui.QTableWidgetItem(text)
				self.setItem(i, 1, item)
				item.setFlags(self.defaultFlags)
				#item = QtGui.QTableWidgetItem()
				#item.setData(QtCore.Qt.DisplayRole, QtCore.QVariant(True))
				#item.setFlags(QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsUserCheckable)
				checkbox = QtGui.QCheckBox(self)
				checkbox.setCheckState(QtCore.Qt.Checked)
				self.checkboxes.append(checkbox)
				self.setCellWidget(i, 0, checkbox)
				
				if dim == 1:
					button = QtGui.QPushButton("histogram: " + text, self)
					def plot(pair=pair):
						self.mainPanel.histogram(*pair)
					button.clicked.connect(plot)
					self.setCellWidget(i, 3, button)
				if dim == 2:
					button = QtGui.QPushButton("plotxy: " + text, self)
					def plot(pair=pair):
						self.mainPanel.plotxy(*pair)
					button.clicked.connect(plot)
					self.setCellWidget(i, 3, button)
				#self.setItem(i, 1, item)
			self.setSortingEnabled(True)
			
	def getSelected(self):
		selection = [checkbox.checkState() == QtCore.Qt.Checked for checkbox in self.checkboxes]
		selected_pairs = [pair for pair, selected in zip(self.pairs, selection) if selected]
		return selected_pairs
		
	def setQualities(self, pairs, qualities):
		for quality, pair in zip(qualities, pairs):
			#item = self.pair_to_item[pair]
			print "quality", quality, qualities
			row = self.pairs.index(pair)
			item = QtGui.QTableWidgetItem()#"%s"  % quality)
			item.setText("%s"  % quality)
			item.setData(QtCore.Qt.DisplayRole, float(quality))
			item.setFlags(self.defaultFlags)
			self.setItem(row, 2, item)
			
			
		
	def setPairs(self, pairs):
		self.pairs = pairs
		selection = [checkbox.checkState() == QtCore.Qt.Checked for checkbox in self.checkboxes]
		non_selected_pairs = [pair for pair, selected in zip(self.pairs, selection) if not selected]
		self.checkboxes = []
		self.setRowCount(len(self.pairs))
		self.setVerticalHeaderLabels(map(str, range(len(self.pairs))))
		for i in range(len(self.pairs)):
			text = " ".join(map(str, self.pairs[i]))
			print text
			item = QtGui.QTableWidgetItem(text)
			item.setFlags(self.defaultFlags)
			self.setItem(i, 1, item)
			checkbox = QtGui.QCheckBox(self)
			if not (self.pairs[i] in non_selected_pairs):
				checkbox.setCheckState(QtCore.Qt.Checked)
			self.checkboxes.append(checkbox)
			self.setCellWidget(i, 0, checkbox)
		print self.checkboxes
		
import functools

def joinpairs(pairs1d, pairsNd):
	previous = []
	for pair1d in pairs1d:
		subspacename = pair1d[0] # tuple only has one element
		for pairNd in pairsNd:
			if subspacename not in pairNd:
				pair = pair1d + pairNd
				if sorted(pair) not in previous:
					previous.append(sorted(pair))
					print previous
					yield pair

class RankDialog(QtGui.QDialog):
	def __init__(self, parent, mainPanel, data):
		super(RankDialog, self).__init__(parent)
		self.data = data
		self.mainPanel = mainPanel
		
		self.tabs = QtGui.QTabWidget(self)
		
		self.tab1d = QtGui.QWidget(self.tabs)
		self.table1d = SubspaceTable(self.tab1d, mainPanel, self.data,  list(itertools.combinations(self.data.column_names, 1)),  1)
		
		self.subspaceTables = {}
		self.subspaceTabs = {}
		self.subspaceTables[1] = self.table1d
		self.subspaceTabs[1] = self.tab1d
		
		self.subspace2d = QtGui.QPushButton("create 2d subspaces", self.tab1d)
		
		def onclick(dim=2):
			pairs1d = self.subspaceTables[1].getSelected()
			pairsprevd = self.subspaceTables[dim-1].getSelected()
			print pairs1d
			print pairsprevd
			newpairs = list(joinpairs(pairs1d, pairsprevd))
			print "newpairs", newpairs
			if dim not in self.subspaceTables:
				self.tabNd = QtGui.QWidget(self.tabs)
				self.tableNd = SubspaceTable(self.tabNd, self.mainPanel, self.data, newpairs, dim)
				self.tabNdlayout = QtGui.QVBoxLayout(self)
				self.subspaceNd = QtGui.QPushButton("create %dd subspaces" % (dim+1), self.tab1d)
				self.rankNd = QtGui.QPushButton("rank subspaces")
				if dim == len(self.data.column_names):
					self.subspaceNd.setDisabled(True)
				self.tabNdlayout.addWidget(self.subspaceNd)
				self.tabNdlayout.addWidget(self.rankNd)
				self.subspaceNd.clicked.connect(functools.partial(onclick, dim=dim+1))
				self.rankNd.clicked.connect(functools.partial(self.rankSubspaces, table=self.tableNd))
				
				def func(index, name=""):
					print name, index.row(), index.column()
				self.tableNd.pressed.connect(functools.partial(func, name="pressed"))
				self.tableNd.entered.connect(functools.partial(func, name="entered"))
				self.tableNd.clicked.connect(functools.partial(func, name="clicked"))
				self.tableNd.activated.connect(functools.partial(func, name="activated"))
				def func(index, previous, name=""):
					print name, index.row(), index.column(), previous.row(), previous.column()
				self.selectionModel = self.tableNd.selectionModel()
				self.selectionModel.currentChanged.connect(functools.partial(func, name="currentChanged"))
				
				self.tabNdlayout.addWidget(self.tableNd)
				#self.tab1dlayout.addWidget(self.rankButton)
				#self.setCentralWidget(self.splitter)
				self.tabNd.setLayout(self.tabNdlayout)
				self.subspaceTables[dim] = self.tableNd
				self.subspaceTabs[dim] = self.tabNd
				
				self.tabs.addTab(self.tabNd, "%dd" % dim)
				self.tabs.setCurrentWidget(self.tabNd)
			else:
				self.subspaceTables[dim].setPairs(newpairs)
				self.tabs.setCurrentWidget(self.subspaceTabs[dim])
			
			
		self.subspace2d.clicked.connect(functools.partial(onclick, dim=2))
		
		
		self.tab1dlayout = QtGui.QVBoxLayout(self)
		self.tab1dlayout.addWidget(self.subspace2d)
		self.tab1dlayout.addWidget(self.table1d)
		#self.tab1dlayout.addWidget(self.rankButton)
		#self.setCentralWidget(self.splitter)
		self.tab1d.setLayout(self.tab1dlayout)
		
		self.tabs.addTab(self.tab1d, "1d")
		
		self.resize(700,500)
		
		if 0:
			for name in self.data.column_names:
				item = QtGui.QListWidgetItem(self.list1d)
				item.setText(name)
				item.setCheckState(False)
				#self.list1d.


		self.boxlayout = QtGui.QHBoxLayout(self)
		self.boxlayout.addWidget(self.tabs)
		#self.boxlayout.addWidget(self.rankButton)
		#self.setCentralWidget(self.splitter)
		self.setLayout(self.boxlayout)
		
	def rankSubspaces(self, table):
		print table
		qualities = []
		pairs = table.getSelected()
		for pair in pairs:
			dim = len(pair)
			#if dim == 2:
			columns = [self.data.columns[name] for name in pair]
			print pair
			information = vaex.kld.kld_shuffled(columns)
			qualities.append(information)
			#print pair
		print qualities
		table.setQualities(pairs, qualities)
		
		
class FullTableModel(QtCore.QAbstractTableModel): 
	def __init__(self, data, parent=None, *args): 
		QtCore.QAbstractTableModel.__init__(self, parent, *args) 
		self.data_ = data
	
	def rowCount(self, parent): 
		#print self.data_._length
		return int(self.data_._length)

	def columnCount(self, parent): 
		return len(self.data_.all_column_names)

	def data(self, index, role):
		#return ""
		if not index.isValid(): 
			return None
		elif role != QtCore.Qt.DisplayRole: 
			return None
		column = self.data_.all_columns[self.data_.all_column_names[index.column()]]
		if len(column.shape) == 1:
			return str(column[index.row()])
		else:
			
			return "%s %s" % (column.dtype.name, column.shape)

	def headerData(self, index, orientation, role):
		#print index
		if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
			return self.data_.all_column_names[index]
		if orientation == QtCore.Qt.Vertical and role == QtCore.Qt.DisplayRole:
			return str(index+1)
		return None

class TableDialog(QtGui.QDialog):
	def __init__(self, parent, data):
		super(TableDialog, self).__init__(parent)
		self.data = data
		
		self.resize(700, 500)
		self.tableView = QtGui.QTableView()
		self.header = self.data.column_names
		self.tableModel = FullTableModel(self.data)
		self.tableView.setModel(self.tableModel)
		self.tableView.pressed.connect(self.onSelectRow)
		
		if 0:
			for name in self.data.column_names:
				item = QtGui.QListWidgetItem(self.list1d)
				item.setText(name)
				item.setCheckState(False)
				#self.list1d.


		self.boxlayout = QtGui.QHBoxLayout(self)
		self.boxlayout.addWidget(self.tableView)
		#self.setCentralWidget(self.splitter)
		self.setLayout(self.boxlayout)
		
	def onSelectRow(self, model):
		row_index = model.row()
		self.data.selectRow(row_index)
		
		
class MainPanel(QtGui.QFrame):
	def __init__(self, parent):
		super(MainPanel, self).__init__(parent)

		self.dataset = None

		self.form_layout = QtGui.QFormLayout()
		
		self.name = QtGui.QLabel('', self)
		self.form_layout.addRow('Name:', self.name)
		
		self.columns = QtGui.QLabel('', self)
		self.form_layout.addRow('Columns:', self.columns)
		
		self.length = QtGui.QLabel('', self)
		self.form_layout.addRow('Length:', self.length)
		
		#self.histogramButton = QtGui.QPushButton('histogram (1d)', self)
		self.histogramButton = QtGui.QToolButton(self)
		self.histogramButton.setText('histogram (1d)')
		self.form_layout.addRow('Plotting:', self.histogramButton)

		self.scatterButton = QtGui.QToolButton(self)
		self.scatterButton.setText('x/y density')
		self.form_layout.addRow('', self.scatterButton)
		
		self.scatter3dButton = QtGui.QToolButton(self)
		self.scatter3dButton.setText('x/y/z density')
		self.form_layout.addRow('', self.scatter3dButton)
		
		
		self.scatter1dSeries = QtGui.QPushButton('series', self)
		self.form_layout.addRow('', self.scatter1dSeries)
		
		self.scatter2dSeries = QtGui.QPushButton('x/y series', self)
		self.form_layout.addRow('', self.scatter2dSeries)
		
		self.serieSlice = QtGui.QToolButton(self)
		self.serieSlice.setText('serie slice')
		self.form_layout.addRow('', self.serieSlice)
		
		self.statistics = QtGui.QPushButton('Statistics', self)
		self.form_layout.addRow('Data:', self.statistics)
		
		self.rank = QtGui.QPushButton('Rank subspaces', self)
		self.form_layout.addRow('', self.rank)
		
		self.table = QtGui.QPushButton('Open table', self)
		self.form_layout.addRow('', self.table)
		
		self.fractionLabel = QtGui.QLabel('Fraction used: ...')
		self.fractionWidget = QtGui.QWidget(self)
		self.fractionLayout = QtGui.QHBoxLayout(self.fractionWidget)
		self.fractionSlider = QtGui.QSlider(QtCore.Qt.Horizontal, self)
		self.fractionSlider.setMinimum(0)
		self.fractionSlider.setMaximum(len(possibleFractions)-1)
		self.numberLabel = QtGui.QLabel('')

		self.fractionLayout.addWidget(self.fractionSlider)
		self.fractionLayout.addWidget(self.numberLabel)
		self.fractionWidget.setLayout(self.fractionLayout)
		#self.fractionSlider.setTickInterval(len(possibleFractions))
		self.form_layout.addRow(self.fractionLabel, self.fractionWidget)
		
		
		
		self.fractionSlider.valueChanged.connect(self.onValueChanged)
		self.onValueChanged(0)
		
		
		self.histogramButton.clicked.connect(self.onOpenHistogram)
		self.statistics.clicked.connect(self.onOpenStatistics)
		self.scatterButton.clicked.connect(self.onOpenScatter)
		self.scatter3dButton.clicked.connect(self.onOpenScatter3d)
		self.scatter1dSeries.clicked.connect(self.onOpenScatter1dSeries)
		self.scatter2dSeries.clicked.connect(self.onOpenScatter2dSeries)
		self.serieSlice.clicked.connect(self.onOpenSerieSlice)
		self.rank.clicked.connect(self.onOpenRank)
		self.table.clicked.connect(self.onOpenTable)
		
		self.setLayout(self.form_layout)
		
	def onOpenStatistics(self):
		print "open", self.dataset
		if self.dataset is not None:
			dialog = StatisticsDialog(self, self.dataset)
			dialog.show()
			print "show"
		
	def onOpenScatter(self):
		print "open", self.dataset
		if self.dataset is not None:
			xname, yname = self.dataset.column_names[:2]
			self.plotxy(xname, yname)
		
	def onOpenScatter3d(self):
		if self.dataset is not None:
			xname, yname, zname = self.dataset.column_names[:3]
			self.plotxyz(xname, yname, zname)
		
	def onOpenSerieSlice(self):
		if self.dataset is not None:
			xname, yname = self.dataset.rank1names[:2]
			self.plotseriexy(xname, yname)
			
	def onOpenScatter1dSeries(self):
		print "open", self.dataset
		if self.dataset is not None:
			dialog = ScatterSeries1dPlotDialog(self, self.dataset)
			dialog.show()
			print "show"
		
	def onOpenScatter2dSeries(self):
		print "open", self.dataset
		if self.dataset is not None:
			dialog = ScatterSeries2dPlotDialog(self, self.dataset)
			dialog.show()
			print "show"
			
	def onOpenHistogram(self):
		if self.dataset is not None:
			xname = self.dataset.column_names[0]
			self.histogram(xname)
			
	def plotxy(self, xname, yname):
		dialog = ScatterPlotDialog(self, self.dataset, xname, yname)
		dialog.show()
		print "show"
			
	def plotxyz(self, xname, yname, zname):
		dialog = PlotDialog3d(self, self.dataset, xname, yname, zname)
		dialog.show()
		print "show"
		
	def histogram(self, xname):
		dialog = HistogramPlotDialog(self, self.dataset, xname)
		dialog.show()
		
		
	def onOpenRank(self):
		print "open", self.dataset
		if self.dataset is not None:
			dialog = RankDialog(self, self, self.dataset)
			dialog.show()
		
	def onOpenTable(self):
		print "open", self.dataset
		if self.dataset is not None:
			dialog = TableDialog(self, self.dataset)
			dialog.show()
			
	def onValueChanged(self, index):
		print index, len(possibleFractions)
		fraction = possibleFractions[index]
		text = 'Fraction used: %9.4f%%' % (fraction*100)
		self.fractionLabel.setText(text)
		if self.dataset:
			self.dataset.setFraction(fraction)
			N  = self.dataset.current_slice[1] - self.dataset.current_slice[0]
			print N
			self.numberLabel.setText("% 10d" % N)
		
	def onDataSelected(self, data_item, previous):
		print "previous:", previous
		if data_item is not None:
			data = data_item.data(QtCore.Qt.UserRole)	
			if hasattr(data, "toPyObject"):
				data = data.toPyObject()
			self.dataset = data
			self.dataset = data
			self.name.setText(data.name)
			self.columns.setText(str(len(data.columns)))
			self.length.setText(str(data._length))
			print self.dataset
			fraction = self.dataset.fraction
			distances = np.abs(np.array(possibleFractions) - fraction)
			index = np.argsort(distances)[0]
			print "best index:", index
			self.fractionSlider.setValue(index) # this will fire an event and execute the above event code
			self.scatterButton.setEnabled(len(self.dataset.columns) > 0)
			self.scatter2dSeries.setEnabled(len(self.dataset.rank1s) >= 2)
			self.scatter1dSeries.setEnabled(len(self.dataset.rank1s) >= 1)
			self.serieSlice.setEnabled(len(self.dataset.rank1s) >= 2)
			
			self.histogramMenu = QtGui.QMenu(self)
			for column_name in self.dataset.column_names:
				#action = QtGui.QAction
				#QtGui.QAction(QtGui.QIcon(iconfile('glue_cross')), '&Pick', self)
				action = QtGui.QAction(column_name, self)
				action.triggered.connect(functools.partial(self.histogram, xname=column_name))
				self.histogramMenu.addAction(action)
			self.histogramButton.setMenu(self.histogramMenu)
			
			self.scatterMenu = QtGui.QMenu(self)
			for column_name1 in self.dataset.column_names:
				#action1 = QtGui.QAction(column_name, self)
				submenu = self.scatterMenu.addMenu(column_name1)
				for column_name2 in self.dataset.column_names:
					action = QtGui.QAction(column_name2, self)
					action.triggered.connect(functools.partial(self.plotxy, xname=column_name1, yname=column_name2))
					submenu.addAction(action)
			self.scatterButton.setMenu(self.scatterMenu)
			
			self.serieSliceMenu = QtGui.QMenu(self)
			for column_name1 in self.dataset.rank1names:
				#action1 = QtGui.QAction(column_name, self)
				submenu = self.serieSliceMenu.addMenu(column_name1)
				for column_name2 in self.dataset.rank1names:
					action = QtGui.QAction(column_name2, self)
					action.triggered.connect(functools.partial(self.plotseriexy, xname=column_name1, yname=column_name2))
					submenu.addAction(action)
			self.serieSlice.setMenu(self.serieSliceMenu)
			
	def plotseriexy(self, xname, yname):
		if self.dataset is not None:
			dialog = SerieSlicePlotDialog(self, self.dataset, xname, yname)
			dialog.show()
			print "show"
			
			
from numba import jit
import numba
print numba.__version__
import math
#@jit('(f8[:],f8[:], i4[:,:], f8, f8, f8, f8)')
@jit(nopython=True)
def histo2d(x, y, counts, dataminx, datamaxx, dataminy, datamaxy):
	length = len(x)
	#counts = np.zeros((bincountx, bincounty), dtype=np.int32)
	bincountx, bincounty = counts.shape
	#print length
	#return bindata#
	for i in range(length):
		binNox = int(math.floor( ((float(x[i]) - dataminx) / (float(datamaxx) - dataminx)) * float(bincountx)))
		binNoy = int(math.floor( ((float(y[i]) - dataminy) / (float(datamaxy) - dataminy)) * float(bincounty)))
		if binNox >= 0 and binNox < bincountx and binNoy >= 0 and binNoy < bincounty:
			counts[binNox, binNoy] += 1
	#step = float(datamax-datamin)/bincount
	#return numpy.arange(datamin, datamax+step/2, step), binData
	return counts
	#for i in range(N):
	#	offset = data[

@jit(nopython=True)
def find_nearest_index(datax, datay, x, y, wx, wy):
	N = len(datax)
	index = 0
	mindistance = math.sqrt((datax[0]-x)**2/wx**2 + (datay[0]-y)**2/wy**2)
	for i in range(1,N):
		distance = math.sqrt((datax[i]-x)**2/wx**2 + (datay[i]-y)**2/wy**2)
		if distance < mindistance:
			mindistance = distance
			index = i
	return index
		
@jit(nopython=True)
def find_nearest_index1d(datax, x):
	N = len(datax)
	index = 0
	mindistance = math.sqrt((datax[0]-x)**2)
	for i in range(1,N):
		distance = math.sqrt((datax[i]-x)**2)
		if distance < mindistance:
			mindistance = distance
			index = i
	return index
		


import mab.utils.numpy

class PlotDialog(QtGui.QDialog):
	def addAxes(self):
		self.axes = self.fig.add_subplot(111)
		self.axes.hold(True)
		
	def getAxesList(self):
		return [self.axes]
	
	def __init__(self, parent, dataset, width=5, height=4, dpi=100):
		super(PlotDialog, self).__init__(parent)
		self.resize(700,700)
		self.dataset = dataset
		
		self.fig = Figure(figsize=(width, height), dpi=dpi)
		self.addAxes()
		
		self.canvas =  FigureCanvas(self.fig)
		self.canvas.setParent(self)

		self.boxlayout = QtGui.QVBoxLayout(self)

		self.xmin_show, self.xmax_show = None, None
		self.ymin_show, self.ymax_show = None, None
		self.xmin, self.xmax = None, None
		self.ymin, self.ymax = None, None
		self.currentModes = None
		self.lastAction = None

		self.beforeCanvas(self.boxlayout)
		self.boxlayout.addWidget(self.canvas, 1)
		self.afterCanvas(self.boxlayout)
		self.setLayout(self.boxlayout)
		
		self.compute()
		self.plot()
		FigureCanvas.setSizePolicy(self,
									QtGui.QSizePolicy.Expanding,
									QtGui.QSizePolicy.Expanding)
		FigureCanvas.updateGeometry(self)
		self.currentMode = None
		self.dataset.mask_listeners.append(self.onSelectMask)
		self.dataset.row_selection_listeners.append(self.onSelectRow)
		
	def closeEvent(self, event):
		print "close event"
		self.dataset.mask_listeners.remove(self.onSelectMask)
		self.dataset.row_selection_listeners.remove(self.onSelectRow)
		
		super(PlotDialog, self).closeEvent(event)
			
	def onSelectMask(self, mask):
		self.compute()
		self.plot()
		
	def onSelectRow(self, row):
		print "row selected", row
		self.plot()
			
	
		
	def beforeCanvas(self, layout):
		pass
	
	def afterCanvas(self, layout):
		pass
	
	def setMode(self, action, force=False):
		print "set mode", action, action.text(), action.isChecked()
		#if not (action.isChecked() or force):
		if not (action.isChecked()):
			print "ignore action"
		else:
			self.lastAction = action
			if self.currentModes is not None:
				print "disconnect", self.currentModes
				for mode in self.currentModes:
					mode.disconnect_events()
					mode.active = False
			if action == self.action_pick:
				hasy = hasattr(self, "getdatay")
				hasx = hasattr(self, "getdatax")
				print "pick", hasx, hasy
				axes_list = self.getAxesList()
				self.currentModes = [matplotlib.widgets.Cursor(axes, hasy, hasx, color="red", linestyle="dashed") for axes in axes_list]
				if hasx and hasy:
					for mode in self.currentModes:
						mode.connect_event('button_press_event', self.onPickXY)
				elif hasx:
					for mode in self.currentModes:
						mode.connect_event('button_press_event', self.onPickX)
				elif hasy:
					for mode in self.currentModes:
						mode.connect_event('button_press_event', self.onPickY)
			if action == self.action_xrange:
				self.currentModes = [matplotlib.widgets.SpanSelector(self.axes, self.onSelectX, 'horizontal')]
			if action == self.action_yrange:
				self.currentModes = [matplotlib.widgets.SpanSelector(self.axes, self.onSelectY, 'vertical')]
			if action == self.action_lasso:
				self.currentModes =[ matplotlib.widgets.LassoSelector(self.axes, self.onSelectLasso)]
				self.canvas.draw() # bug fix for LassoSelector
			if action == self.action_zoom_x:
				print "xrange"
				self.currentModes = [matplotlib.widgets.SpanSelector(self.axes, self.onZoomX, 'horizontal')] #, rectprops={"color":"blue"})
			if action == self.action_zoom_y:
				print "yrange"
				self.currentModes = [matplotlib.widgets.SpanSelector(self.axes, self.onZoomY, 'vertical')] #, rectprops={"color":"blue"})
			if action == self.action_zoom_rect:
				print "rect"
				self.currentModes = [matplotlib.widgets.RectangleSelector(self.axes, self.onZoomRect)] #, rectprops={"color":"blue"})
				
		#if self.action_lasso
		#pass
		#self.
		
	def onPickX(self, event):
		x, y = event.xdata, event.ydata
		row = find_nearest_index1d(self.getdatax(), x)
		print "nearest row", row, x, self.getdatax()[row]
		self.dataset.selectRow(row)
		self.setMode(self.lastAction)
		
	def onPickXY(self, event):
		x, y = event.xdata, event.ydata
		row = find_nearest_index1d(self.getdatay(), y)
		print "nearest row", row, x, self.getdatax()[row]
		self.dataset.selectRow(row)
		self.setMode(self.lastAction)
		
	def onPickXY(self, event):
		x, y = event.xdata, event.ydata
		wx = self.xmax - self.xmin
		wy = self.ymax - self.ymin
		row = find_nearest_index(self.getdatax(), self.getdatay(), x, y, wx, wy)
		print "nearest row", row, x, y, self.getdatax()[row], self.getdatay()[row]
		self.dataset.selectRow(row)
		self.setMode(self.lastAction)
		
		
	def onSelectX(self, xmin, xmax):
		data = self.getdatax()
		x = [xmin, xmax]
		xmin, xmax = min(x), max(x)
		print "selectx", xmin, xmax
		xmin = xmin if not self.useLogx() else 10**xmin
		xmax = xmax if not self.useLogx() else 10**xmax
		mask = (data >= xmin) & (data < xmax)
		print "selectx", xmin, xmax, "selected", np.sum(mask)
		self.dataset._set_mask(mask)
		self.setMode(self.lastAction)
		
	def onSelectY(self, ymin, ymax):
		data = self.getdatay()
		y = [ymin, ymax]
		ymin, ymax = min(y), max(y)
		mask = (data >= ymin) & (data < ymax)
		print "selecty", ymin, ymax, "selected", np.sum(mask)
		self.dataset._set_mask(mask)
		self.setMode(self.lastAction)
		
	def onSelectLasso(self, vertices):
		x, y = np.array(vertices).T
		x = np.ascontiguousarray(x, dtype=np.float64)
		y = np.ascontiguousarray(y, dtype=np.float64)
		mask = np.zeros(len(self.getdatax()), dtype=np.uint8)
		meanx = x.mean()
		meany = y.mean()
		radius = np.sqrt((meanx-x)**2 + (meany-y)**2).max()
		#print (x, y, self.parent.datax, self.parent.datay, mask, meanx, meany, radius)
		try:
			vaex.selection.pnpoly(x, y, self.getdatax(), self.getdatay(), mask, meanx, meany, radius)
		except:
			print vaex.selection.pnpoly.inspect_types()
			args = (x, y, self.getdatax(), self.getdatay(), mask, meanx, meany, radius)
			print "issue with pnppoly, arguments: "
			for i, arg in enumerate(args):
				print i, repr(arg), arg.dtype if hasattr(arg, "dtype") else ""
			raise
		self.dataset._set_mask(mask==1)
		self.setMode(self.lastAction)
		
	def onZoomX(self, xmin, xmax):
		#print "zoom x", xmin, xmax
		#self.
		self.xmin_show, self.xmax_show = xmin, xmax
		#self.axes.set_xlim(self.xmin, self.xmax)
		#self.canvas.draw()
		self.plot()
		
	def onZoomY(self, ymin, ymax):
		self.ymin_show, self.ymax_show = ymin, ymax
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#self.canvas.draw()
		self.plot()
		
	def onZoomRect(self, eclick, erelease):
		x1, y1 = (eclick.xdata, eclick.ydata)
		x2, y2 = (erelease.xdata, erelease.ydata)
		x = [x1, x2]
		y = [y1, y2]
		
		self.xmin_show, self.xmax_show = min(x), max(x)
		self.ymin_show, self.ymax_show = min(y), max(y)
		
		self.axes.set_xlim(self.xmin_show, self.xmax_show)
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#self.canvas.draw()
		self.plot()
		
	def onZoomOut(self, *args):
		xmin, xmax = self.axes.get_xlim()
		width = xmax - xmin
		self.xmin_show, self.xmax_show = xmin - width , xmax + width
		self.axes.set_xlim(self.xmin_show, self.xmax_show)
		ymin, ymax = self.axes.get_ylim()
		height = ymax - ymin
		self.ymin_show, self.ymax_show = ymin - height, ymax + height
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#self.canvas.draw()
		self.plot()
		
	def onZoomFit(self, *args):
		self.xmin_show, self.xmax_show = self.xmin, self.xmax = self.getxrange()
		self.ymin_show, self.ymax_show = self.ymin, self.ymax = None, None
		self.axes.set_xlim(self.xmin_show, self.xmax_show)
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#self.canvas.draw()
		self.compute()
		self.plot()
		
	def onZoomUse(self, *args):
		self.xmin, self.xmax = self.xmin_show, self.xmax_show
		self.ymin, self.ymax = self.ymin_show, self.ymax_show = None, None
		#self.axes.set_xlim(self.xmin, self.xmax)
		#self.axes.set_ylim(self.ymin, self.ymax)
		#self.canvas.draw()
		self.compute()
		self.plot()
		
	def addToolbar(self, layout, pick=True, xselect=True, yselect=True, lasso=True):
		
		self.toolbar = QtGui.QToolBar(self)
		self.toolbar.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
		self.actionGroup = QtGui.QActionGroup(self)
		self.action_pick = QtGui.QAction(QtGui.QIcon(iconfile('glue_cross')), '&Pick', self)        
		self.action_xrange = QtGui.QAction(QtGui.QIcon(iconfile('glue_xrange_select')), '&x-range', self)        
		self.action_yrange = QtGui.QAction(QtGui.QIcon(iconfile('glue_yrange_select')), '&y-range', self)        
		self.action_lasso = QtGui.QAction(QtGui.QIcon(iconfile('glue_lasso')), '&Lasso', self)        
		self.action_zoom_rect = QtGui.QAction(QtGui.QIcon(iconfile('glue_zoom_to_rect')), '&Zoom to rect', self)        
		#self.action_zoom_rect.setIconText("rect")

		#self.actionGroupZoom = QtGui.QActionGroup(self)
		self.action_zoom_x = QtGui.QAction(QtGui.QIcon(iconfile('glue_zoom_to_rect')), '&Zoom x', self)        
		self.action_zoom_y = QtGui.QAction(QtGui.QIcon(iconfile('glue_zoom_to_rect')), '&Zoom y', self)        
		self.action_zoom_out = QtGui.QAction(QtGui.QIcon(iconfile('glue_zoom_to_rect')), '&Zoom out', self)        
		self.action_zoom_fit = QtGui.QAction(QtGui.QIcon(iconfile('glue_move')), '&Zoom to fit', self)        
		self.action_zoom_use = QtGui.QAction(QtGui.QIcon(iconfile('glue_move')), '&Use zoom area', self)        

		#self.zoomButton = QtGui.QToolButton(self, )
		#$self.zoomButton.setIcon(QtGui.QIcon(iconfile('glue_zoom_to_rect')))
		#self.zoomMenu = QtGui.QMenu(self)
		#self.zoomMenu.addAction(self.action_zoom_x)
		#self.zoomMenu.addAction(self.action_zoom_y)
		#self.zoomMenu.addAction(self.action_zoom_out)
		#self.action_zoom.setMenu(self.zoomMenu)
		#self.action_zoom = self.toolbar.addWidget(self.zoomButton)
		
		#self.action_zoom = QtGui.QAction(QtGui.QIcon(iconfile('glue_zoom_to_rect')), '&Zoom', self)        
		#exitAction.setShortcut('Ctrl+Q')
		#exitAction.setStatusTip('Exit application')

		#self.actionGroup.setToggleAction(True)
		#self.actionGroup.setExclusive(True)
		self.actionGroup.addAction(self.action_pick)
		self.actionGroup.addAction(self.action_xrange)
		self.actionGroup.addAction(self.action_yrange)
		self.actionGroup.addAction(self.action_lasso)
		self.actionGroup.addAction(self.action_zoom_rect)
		self.actionGroup.addAction(self.action_zoom_x)
		self.actionGroup.addAction(self.action_zoom_y)
		#self.actionGroup.addAction(self.action_zoom_out)
		if pick:
			self.toolbar.addAction(self.action_pick)
			#self.action_pick.setChecked(True)
			#self.setMode(self.action_pick, force=True)
			self.lastAction = self.action_pick
		if xselect:
			self.toolbar.addAction(self.action_xrange)
		if yselect:
			self.toolbar.addAction(self.action_yrange)
		if lasso:
			self.toolbar.addAction(self.action_lasso)
		self.toolbar.addAction(self.action_zoom_rect)
		self.toolbar.addAction(self.action_zoom_x)
		self.toolbar.addAction(self.action_zoom_y)
		self.toolbar.addSeparator()
		self.toolbar.addAction(self.action_zoom_out)
		self.toolbar.addAction(self.action_zoom_fit)
		self.toolbar.addAction(self.action_zoom_use)
		
		
		#self.zoomButton.setPopupMode(QtCore.QToolButton.DelayedPopup)
		
		
		self.actionGroup.triggered.connect(self.setMode)
		self.action_zoom_out.triggered.connect(self.onZoomOut)
		self.action_zoom_fit.triggered.connect(self.onZoomFit)
		self.action_zoom_use.triggered.connect(self.onZoomUse)
		#action_zoom_out
		self.action_pick.setCheckable(True)
		self.action_pick.setChecked(True)
		self.action_xrange.setCheckable(True)
		self.action_yrange.setCheckable(True)
		self.action_lasso.setCheckable(True)
		self.action_zoom_rect.setCheckable(True)
		self.action_zoom_x.setCheckable(True)
		self.action_zoom_y.setCheckable(True)
		#self.action_zoom_out.setCheckable(True)
		#self.actionGroup.
		
		#action = self.toolbar.addAction(icon
		layout.addWidget(self.toolbar)
		
		
		
def iconfile(name):
	path = os.path.join(os.path.dirname(vaex.__file__), "icons", name+".png")
	print "icon path:", path
	return path

class PlotDialogNd(PlotDialog):
	def __init__(self, parent, dataset, names, axisnames):
		self.axisnames = axisnames
		self.dataset = dataset
		assert len(names) == len(axisnames)
		column_names = self.getColumnNames()
		self.currentAxes = [column_names.index(name) for name in names]
		self.axisNames = [column_names[index] for index in self.currentAxes]
		column_dict = self.getColumnDict()
		self.datalist = [column_dict[name] for name in self.axisNames]
		self.nAxes = len(self.datalist)
		self.axeslist = range(self.nAxes)
		self.ranges_show = None
		self.ranges = None
		super(PlotDialogNd, self).__init__(parent, dataset)
		
	def addAxes(self):
		self.axes_grid = [[None,] * self.nAxes for _ in self.axeslist]
		index = 0
		for i in self.axeslist[::1]:
			for j in self.axeslist[::1]:
				index = ((self.nAxes-1)-j) * self.nAxes + i + 1
				axes = self.axes_grid[i][j] = self.fig.add_subplot(self.nAxes,self.nAxes,index)
#													   sharey=self.axes_grid[0][j] if j > 0 else None,
#													   sharex=self.axes_grid[i][0] if i > 0 else None
#													   )
				if i > 0:
					for label in axes.get_yticklabels():
						label.set_visible(False)
					axes.yaxis.offsetText.set_visible(False)
				if j > 0:
					for label in axes.get_xticklabels():
						label.set_visible(False)
					axes.xaxis.offsetText.set_visible(False)
				self.axes_grid[i][j].hold(True)
				index += 1
		self.fig.subplots_adjust(hspace=0, wspace=0)

		
	def afterCanvas(self, layout):
		#self.mpl_toolbar = NavigationToolbar(self.canvas, self.axes, self)
		
		self.form_layout = QtGui.QFormLayout(self)

		self.axisboxes = []
		axisIndex = 0
		for axisname in self.axisnames:
			axisbox = QtGui.QComboBox(self)
			self.form_layout.addRow(axisname + '-axis:', axisbox)
			axisbox.addItems(self.getColumnNames())
			axisbox.setCurrentIndex(self.currentAxes[axisIndex])
			axisbox.currentIndexChanged.connect(functools.partial(self.onAxis, axisIndex=axisIndex))
			axisIndex += 1
		layout.addLayout(self.form_layout, 0)

	def onAxis(self, index, axisIndex=0):
		self.currentAxes[axisIndex] = index
		self.axisNames[axisIndex] = self.getColumnNames()[self.currentAxes[axisIndex]]
		print "axis index %d (%s) changed, index=%d, name=%s" % (axisIndex, self.axisnames[axisIndex], index, self.axisNames[axisIndex])
		self.datalist[axisIndex] = self.getColumnDict()[self.axisNames[axisIndex]][slice(*self.dataset.current_slice)]
		self.ranges[axisIndex] = None
		self.ranges_show[axisIndex] = None
		#self.onXDataSelected(self.datax)
		self.compute()
		self.plot()
		
	def getrange(self, axisIndex):
		return np.nanmin(self.datalist[axisIndex]), np.nanmax(self.datalist[axisIndex])

	def onZoomFit(self, *args):
		self.ranges_show = [self.getrange(axis) for axis in self.axes]
		self.ranges = [range_ for range_ in self.ranges_show]
		#self.axes.set_xlim(self.xmin_show, self.xmax_show)
		#self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#self.canvas.draw()
		self.compute()
		self.plot()

	def onZoomUse(self, *args):
		self.xmin, self.xmax = self.xmin_show, self.xmax_show
		self.ymin, self.ymax = self.ymin_show, self.ymax_show
		#self.axes.set_xlim(self.xmin, self.xmax)
		#self.axes.set_ylim(self.ymin, self.ymax)
		#self.canvas.draw()
		self.compute()
		self.plot()
		
	def beforeCanvas(self, layout):
		self.addToolbar(layout) #, yselect=True, lasso=False)
		
	def getdatax(self):
		return None
	def getdatay(self):
		return None

class PlotDialog3d(PlotDialogNd):
	def __init__(self, parent, dataset, xname=None, yname=None, zname=None):
		super(PlotDialog3d, self).__init__(parent, dataset, [xname, yname, zname], "X Y Z".split())
		
	def getAxesList(self):
		return reduce(lambda x,y: x + y, self.axes_grid, [])

	def getColumnNames(self):
		return self.dataset.column_names
	
	def getColumnDict(self):
		return self.dataset.columns
	
	def compute(self):
		if self.ranges_show is None:
			self.ranges_show = [self.getrange(axis) for axis in self.axeslist]
		for i in self.axeslist:
			if self.ranges_show[i] is None:
				self.ranges_show[i] = self.getrange(i)
		if self.ranges is None:
			self.ranges = [range_ for range_ in self.ranges_show]
		for i in self.axeslist:
			if self.ranges[i] is None:
				self.ranges[i] = self.ranges_show[i]
			
		Nhisto = 128
		self.counts = np.zeros((Nhisto, ) * self.nAxes, dtype=np.float64)
		assert self.nAxes == 3
		vaex.histogram.hist3d(self.datalist[0], self.datalist[1], self.datalist[2], self.counts, *(self.ranges[0] + self.ranges[1] + self.ranges[2]))
		
	def plot(self):
		def multisum(a, axes):
			correction = 0
			for axis in axes:
				a = np.sum(a, axis=axis-correction)
				correction += 1
			return a		
		for i in self.axeslist:
			for j in self.axeslist:
				axes = self.axes_grid[i][j]
				ranges = self.ranges[i] + self.ranges[j]
				axes.clear()
				allaxes = range(self.nAxes)
				if i > 0:
					for label in axes.get_yticklabels():
						label.set_visible(False)
					axes.yaxis.offsetText.set_visible(False)
				if j > 0:
					for label in axes.get_xticklabels():
						label.set_visible(False)
					axes.xaxis.offsetText.set_visible(False)
				if i != j:
					allaxes.remove(i)
					allaxes.remove(j)
					counts = multisum(self.counts, allaxes)
					if i < j:
						counts = counts.T
					axes.imshow(np.log10(counts), origin="lower", extent=ranges) #, alpha=1 if self.counts_mask is None else 0.4)
					axes.set_aspect('auto')
					if self.dataset.selected_row_index is not None:
						#self.axes.autoscale(False)
						x, y = self.getdatax()[self.dataset.selected_row_index],  self.getdatay()[self.dataset.selected_row_index]
						print "drawing selected point at", x, y
						axes.scatter([x], [y], color='red') #, scalex=False, scaley=False)
					
					axes.set_xlim(self.ranges_show[i][0], self.ranges_show[i][1])
					axes.set_ylim(self.ranges_show[j][0], self.ranges_show[j][1])
				else:
					allaxes.remove(j)
					counts = multisum(self.counts, allaxes)
					N = len(counts)
					xmin, xmax = self.ranges[i]
					delta = (xmax - xmin) / N
					centers = np.arange(N) * delta + xmin

					#axes.autoscale(False)
					#P.hist(x, 50, normed=1, histtype='stepfilled')
					#values = 
					if 1: #if self.counts_mask is None:
						axes.bar(centers, counts, width=delta, align='center')
					else:
						self.axes.bar(self.centers, self.counts, width=self.delta, align='center', alpha=0.5)
						self.axes.bar(self.centers, self.counts_mask, width=self.delta, align='center', color="red")
					axes.set_xlim(self.ranges_show[i][0], self.ranges_show[i][1])
					axes.set_ylim(0, np.max(counts)*1.1)
					
				#index += 1
		#return
		#self.axes.cla()
		#self.axes.imshow(np.log10(self.counts.T), origin="lower", extent=self.ranges, alpha=1 if self.counts_mask is None else 0.4)
		#if self.counts_mask is not None:
		#	self.axes.imshow(np.log10(self.counts_mask.T), origin="lower", extent=self.ranges, alpha=1)
		#self.axes.imshow((I), origin="lower", extent=ranges)
		#if dataxsel is not None:
		#	self.axes.scatter(dataxsel, dataysel)
		#self.axes.set_xlabel(self.xaxisName)
		#self.axes.set_ylabel(self.yaxisName)
		#print "plot limits:", self.xmin, self.xmax
		#self.axes.set_xlim(self.xmin_show, self.xmax_show)
		#self.axes.set_ylim(self.ymin_show, self.ymax_show)
		self.canvas.draw()
	
class PlotDialog1d(PlotDialog):
	def __init__(self, parent, dataset, name=None, axisname="X"):
		self.axisname = axisname
		self.currentAxis = 0 if name is None else dataset.column_names.index(name)
		self.axisName = dataset.column_names[self.currentAxis]
		self.data = dataset.columns[self.axisName][slice(*dataset.current_slice)]
		self.name = name
		super(PlotDialog1d, self).__init__(parent, dataset)
		
		
	def afterCanvas(self, layout):
		self.mpl_toolbar = NavigationToolbar(self.canvas, self.axes, self)
		
		self.form_layout = QtGui.QFormLayout(self)

		self.axisbox = QtGui.QComboBox(self)
		self.form_layout.addRow(self.axisname + '-axis:', self.axisbox)
		self.axisbox.addItems(self.dataset.column_names)
		self.axisbox.setCurrentIndex(self.currentAxis)
		self.axisbox.currentIndexChanged.connect(self.onAxis)
		
		self.logcheckbox = QtGui.QCheckBox(self)
		self.logcheckbox.hide()
		#self.form_layout.addRow('log10 ' +self.axisname, self.logcheckbox)
		self.logcheckbox.stateChanged.connect(self.onChangeLog)


		layout.addWidget(self.mpl_toolbar, 1)
		layout.addLayout(self.form_layout, 0)
		
	def useLog(self):
		return self.logcheckbox.checkState() == QtCore.Qt.Checked
		
	def useLogx(self):
		return self.useLog()
		
	def onChangeLog(self):
		self.compute()
		self.plot()

	def onAxis(self, index):
		self.currentAxis = index
		self.axisName = self.dataset.column_names[self.currentAxis]
		print "axis changed, index=", self.currentAxis, "name is", self.axisName
		self.data = self.dataset.columns[self.axisName][slice(*self.dataset.current_slice)]
		self.onDataSelected(self.data)
		self.compute()
		self.plot()
		
	def onDataSelected(self, data):
		pass



class HistogramPlotDialog(PlotDialog1d):
	def __init__(self, parent, dataset, name):
		super(HistogramPlotDialog, self).__init__(parent, dataset, name)
		
	def beforeCanvas(self, layout):
		self.addToolbar(layout, yselect=False, lasso=False)
		
	def onChangeLog(self):
		self.xmin, self.xmax = None, None
		self.ymin, self.ymax = None, None
		self.xmin_show, self.xmax_show = None, None
		self.ymin_show, self.ymax_show = None, None
		super(HistogramPlotDialog, self).onChangeLog()
		
	def onDataSelected(self, data):
		self.xmin, self.xmax = None, None
		self.ymin, self.ymax = None, None
		self.xmin_show, self.xmax_show = None, None
		self.ymin_show, self.ymax_show = None, None
		
	def getdatax(self):
		return self.data[slice(*self.dataset.current_slice)]
		
	def getxrange(self):
		return np.nanmin(self.data), np.nanmax(self.data)
		
	def gettotalxrange(self):
		return np.nanmin(self.data), np.nanmax(self.data)
		
	def getyrange(self):
		return 0., np.max(self.counts)
	
	def compute(self):
		if self.xmin is None or self.xmax is None:
			self.xmin, self.xmax = self.getxrange()
			print "compute: setting x limits", self.xmin, self.xmax
		if self.xmin_show is None or self.xmax_show is None:
			self.xmin_show = self.xmin
			self.xmax_show = self.xmax
		#totalxmin, totalxmax = self.gettotalxrange()
		N = 128 #len(self.counts) 
		#print repr(self.data), repr(self.counts), repr(xmin), repr(xmax)
		t0 = time.time()
		data = self.getdatax()
		data_length = len(data)
		if 0:
			parts = 20
			#count_parts = np.zeros((parts, 128), dtype=np.float64)
			counts_parts = mab.utils.numpy.mmapzeros((parts, 128), dtype=np.float64)
			@parallelize(cores=QtCore.QThread.idealThreadCount())
			def histo1d_par(part):
				#N = len(datax)
				i1 = (data_length / parts) * part
				i2 = (data_length / parts) * (part+1)
				#print i1, i2,datax[i1:i2],datay[i1:i2], Iparts[part], ranges
				#histo2d(datax[i1:i2], datay[i1:i2], Iparts[part], *ranges)
				vaex.histogram.hist1d(data[i1:i2], counts_parts[part], self.xmin, self.xmax)
				#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			histo1d_par(range(parts))
			self.counts = np.sum(counts_parts, axis=0)
		else:
			self.counts = np.zeros(128, dtype=np.float64)
			vaex.histogram.hist1d(self.data, self.counts, self.xmin, self.xmax, self.useLog())
			#I = np.zeros((parts, 128, 128), dtype=np.int32)
			#histo2d(datax, datay, Iparts, np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			#I = np.sum(I, axis=0)
			
		if self.dataset.mask is not None:
			data_masked = data[self.dataset.mask]
			data_length = len(data_masked)
			self.counts_mask = mab.utils.numpy.mmapzeros((128), dtype=np.float64)
			vaex.histogram.hist1d(data_masked, self.counts_mask, self.xmin, self.xmax, self.useLog())
		else:
			self.counts_mask = None
		if self.ymin is None or self.ymax is None:
			self.ymin, self.ymax = self.getyrange()
		if self.ymin_show is None or self.ymax_show is None:
			self.ymin_show = self.ymin
			self.ymax_show = self.ymax
		print "it took", time.time()-t0
		
		
		
		self.delta = (self.xmax - self.xmin) / N
		self.centers = np.arange(N) * self.delta + self.xmin
		#print xmin, xmax, self.centers
		
		
	def plot(self):
		self.axes.cla()
		self.axes.autoscale(False)
		#P.hist(x, 50, normed=1, histtype='stepfilled')
		#values = 
		if self.counts_mask is None:
			self.axes.bar(self.centers, self.counts, width=self.delta, align='center')
		else:
			self.axes.bar(self.centers, self.counts, width=self.delta, align='center', alpha=0.5)
			self.axes.bar(self.centers, self.counts_mask, width=self.delta, align='center', color="red")
		
		print "row index", self.dataset.selected_row_index
		if self.dataset.selected_row_index is not None:
			x = self.getdatax()[self.dataset.selected_row_index]
			print "drawing vline at", x
			self.axes.axvline(x, color="red")
		
		#width = self.xmax - self.xmin
		#self.axes.set_xlim(self.xmin - width * 0.01, self.xmax + width * 0.01)
		self.axes.set_xlabel(self.axisName)
		print "plot limits:", self.xmin_show, self.xmax_show
		self.axes.set_xlim(self.xmin_show, self.xmax_show)
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#if self.lastAction is not None:
		#	self.setMode(self.lastAction)
		self.canvas.draw()
		
class PlotDialog2d(PlotDialog):
	def __init__(self, parent, dataset, xname=None, yname=None, xaxisname="X", yaxisname="Y"):
		self.dataset = dataset
		self.xaxisname = xaxisname
		self.yaxisname = yaxisname
		self.currentXAxis = 0 if xname is None else self.getColumnNames().index(xname)
		self.currentYAxis = 1 if yname is None else self.getColumnNames().index(yname)
		self.xaxisName = self.getColumnNames()[self.currentXAxis]
		self.yaxisName = self.getColumnNames()[self.currentYAxis]
		self.datax = self.getColumnDict()[self.xaxisName][slice(*dataset.current_slice)]
		self.datay = self.getColumnDict()[self.yaxisName][slice(*dataset.current_slice)]
		#self.name = name
		super(PlotDialog2d, self).__init__(parent, dataset)

	def getColumnNames(self):
		return self.__dict__['dataset'].column_names
	
	def getColumnDict(self):
		return self.dataset.columns
		
	def afterCanvas(self, layout):
		#self.mpl_toolbar = NavigationToolbar(self.canvas, self.axes, self)
		
		self.form_layout = QtGui.QFormLayout(self)

		self.xaxisbox = QtGui.QComboBox(self)
		self.form_layout.addRow(self.xaxisname + '-axis:', self.xaxisbox)
		self.xaxisbox.addItems(self.getColumnNames())
		self.xaxisbox.setCurrentIndex(self.currentXAxis)
		self.xaxisbox.currentIndexChanged.connect(self.onXAxis)
		
		self.yaxisbox = QtGui.QComboBox(self)
		self.form_layout.addRow(self.yaxisname + '-axis:', self.yaxisbox)
		self.yaxisbox.addItems(self.getColumnNames())
		self.yaxisbox.setCurrentIndex(self.currentYAxis)
		self.yaxisbox.currentIndexChanged.connect(self.onYAxis)
		
		#layout.addWidget(self.mpl_toolbar, 1)
		layout.addLayout(self.form_layout, 0)

	def onXAxis(self, index):
		self.currentXAxis = index
		self.xaxisName = self.getColumnNames()[self.currentXAxis]
		print "x axis changed, index=", self.currentXAxis, "name is", self.xaxisName
		self.datax = self.getColumnDict()[self.xaxisName][slice(*self.dataset.current_slice)]
		self.onXDataSelected(self.datax)
		self.compute()
		self.plot()

	def onYAxis(self, index):
		self.currentYAxis = index
		self.yaxisName = self.getColumnNames()[self.currentYAxis]
		print "axis changed, index=", self.currentYAxis, "name is", self.yaxisName
		self.datay = self.getColumnDict()[self.yaxisName][slice(*self.dataset.current_slice)]
		self.onYDataSelected(self.datay)
		self.compute()
		self.plot()
		
	def onXDataSelected(self, data):
		pass
	
	def onYDataSelected(self, data):
		pass
	
	def onZoomFit(self, *args):
		self.xmin_show, self.xmax_show = self.xmin, self.xmax = self.getxrange()
		self.ymin_show, self.ymax_show = self.ymin, self.ymax = self.getyrange()
		self.axes.set_xlim(self.xmin_show, self.xmax_show)
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		#self.canvas.draw()
		self.compute()
		self.plot()

	def onZoomUse(self, *args):
		self.xmin, self.xmax = self.xmin_show, self.xmax_show
		self.ymin, self.ymax = self.ymin_show, self.ymax_show
		#self.axes.set_xlim(self.xmin, self.xmax)
		#self.axes.set_ylim(self.ymin, self.ymax)
		#self.canvas.draw()
		self.compute()
		self.plot()

class ScatterPlotDialog(PlotDialog2d):
	def __init__(self, parent, dataset, xname=None, yname=None):
		super(ScatterPlotDialog, self).__init__(parent, dataset, xname, yname)
		
	def beforeCanvas(self, layout):
		self.addToolbar(layout) #, yselect=True, lasso=False)
		
	def onXDataSelected(self, data):
		self.xmin, self.xmax = None, None
		self.xmin_show, self.xmax_show = None, None
	
	def onYDataSelected(self, data):
		self.ymin, self.ymax = None, None
		self.ymin_show, self.ymax_show = None, None
		
	def getdatax(self):
		return self.datax[slice(*self.dataset.current_slice)]
	def getdatay(self):
		return self.datay[slice(*self.dataset.current_slice)]
		
	def getxrange(self):
		#data = self.getdatax()
		data = self.datax
		return np.nanmin(data), np.nanmax(data)
		
	#def gettotalxrange(self):
	#	data = self.getdatax()
	#	return np.nanmin(data), np.nanmax(data)
		
	def getyrange(self):
		#data = self.getdatay()
		data = self.datay
		return np.nanmin(data), np.nanmax(data)
		
	def compute(self):
		if self.xmin is None or self.xmax is None:
			self.xmin, self.xmax = self.getxrange()
			if self.xmin == self.xmax:
				self.xmax += 1
		if self.ymin is None or self.ymax is None:
			self.ymin, self.ymax = self.getyrange()
			if self.ymin == self.ymax:
				self.ymax += 1
		if self.xmin_show is None or self.xmax_show is None:
			self.xmin_show, self.xmax_show = self.xmin, self.xmax
		if self.ymin_show is None or self.ymax_show is None:
			self.ymin_show, self.ymax_show = self.ymin, self.ymax
		dataxsel, dataysel = None, None
		datax = self.getdatax()
		datay = self.getdatay()
		if self.dataset.mask is not None:
			#print self.mask
			#print "sum of mask", sum(self.mask)
			dataxsel = datax[self.dataset.mask]
			dataysel = datay[self.dataset.mask]
			#print dataxsel
			#print len(dataxsel)
		
		self.ranges = self.xmin, self.xmax, self.ymin, self.ymax
		#self.ranges = np.nanmin(datax), np.nanmax(datax), np.nanmin(datay), np.nanmax(datay)
		#self.ranges
		t0 = time.time()
		if 0: # BUG: parallelize doesn't work well with numba, maybe precompile first?
			parts = 20
			Iparts = np.zeros((parts, 128, 128))
			Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
			@parallelize(cores=QtCore.QThread.idealThreadCount())
			def histo2d_par(part):
				N = len(datax)
				i1 = (N / parts) * part
				i2 = (N / parts) * (part+1)
				#print i1, i2,datax[i1:i2],datay[i1:i2], Iparts[part], ranges
				try:
					histo2d(datax[i1:i2], datay[i1:i2], Iparts[part], *self.ranges)
				except TypeError:
					print histo2d.inspect_types()
					args = (datax[i1:i2], datay[i1:i2], Iparts[part]) + self.ranges
					for i, arg in enumerate(args):
						print i, repr(arg), arg.dtype if hasattr(arg, "dtype") else ""
					
				#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			histo2d_par(range(parts))
			I = np.sum(Iparts, axis=0)
		else:
			I = np.zeros((128, 128), dtype=np.int32)
			try:
				histo2d(datax, datay, I, *self.ranges)
			except:
				import pdb
				pdb.set_trace()
			#histo2d(datax, datay, Iparts, np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			#I = np.sum(I, axis=0)
		print "it took", time.time()-t0
		self.counts = I
		if dataxsel is not None:
			parts = 20
			Iparts = np.zeros((parts, 128, 128))
			Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
			@parallelize(cores=QtCore.QThread.idealThreadCount())
			def histo2d_par(part):
				N = len(dataxsel)
				i1 = (N / parts) * part
				i2 = (N / parts) * (part+1)
				#print i1, i2,dataxsel[i1:i2],dataysel[i1:i2], Iparts[part], ranges
				histo2d(dataxsel[i1:i2], dataysel[i1:i2], Iparts[part], *self.ranges)
				#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			histo2d_par(range(parts))
			Is = np.sum(Iparts, axis=0)
			self.counts_mask = Is
		else:
			self.counts_mask = None
		
		#I, x, y = np.histogram2d(self.dataset.columns[x], self.dataset.columns[y], bins=128)
		#print res
		#I = res
		
	def plot(self):
		self.axes.cla()
		#extent = 
		#ranges = np.nanmin(datax), np.nanmax(datax), np.nanmin(datay), np.nanmax(datay)
		self.axes.imshow(np.log10(self.counts.T), origin="lower", extent=self.ranges, alpha=1 if self.counts_mask is None else 0.4)
		if self.counts_mask is not None:
			self.axes.imshow(np.log10(self.counts_mask.T), origin="lower", extent=self.ranges, alpha=1)
		#self.axes.imshow((I), origin="lower", extent=ranges)
		self.axes.set_aspect('auto')
		if self.dataset.selected_row_index is not None:
			#self.axes.autoscale(False)
			x, y = self.getdatax()[self.dataset.selected_row_index],  self.getdatay()[self.dataset.selected_row_index]
			print "drawing selected point at", x, y
			self.axes.scatter([x], [y], color='red') #, scalex=False, scaley=False)
		#if dataxsel is not None:
		#	self.axes.scatter(dataxsel, dataysel)
		self.axes.set_xlabel(self.xaxisName)
		self.axes.set_ylabel(self.yaxisName)
		print "plot limits:", self.xmin, self.xmax
		self.axes.set_xlim(self.xmin_show, self.xmax_show)
		self.axes.set_ylim(self.ymin_show, self.ymax_show)
		self.canvas.draw()
	
class SerieSlicePlotDialog(ScatterPlotDialog):
	def __init__(self, parent, dataset, xname=None, yname=None):
		self.serieIndex = 0 if dataset.selected_serie_index is None else dataset.selected_serie_index
		super(SerieSlicePlotDialog, self).__init__(parent, dataset, xname, yname)
		self.dataset.serie_index_selection_listeners.append(self.onSerieIndexSelect)
	
	def afterCanvas(self, layout):
		super(SerieSlicePlotDialog, self).afterCanvas(layout)
		
		self.form_layout = QtGui.QFormLayout(self)

		
		self.nSlices = self.datax.shape[0]
		self.seriesbox = QtGui.QComboBox(self)
		self.seriesbox.addItems([str(k) for k in range(self.nSlices)])
		self.seriesbox.setCurrentIndex(self.serieIndex)
		self.seriesbox.currentIndexChanged.connect(self.onSerieIndex)
		
		self.form_layout.addRow("index", self.seriesbox)
		self.buttonLoop = QtGui.QToolButton(self)
		self.buttonLoop.setText("one loop")
		self.buttonLoop.clicked.connect(self.onPlayOnce)
		self.form_layout.addRow("movie", self.buttonLoop)
		layout.addLayout(self.form_layout, 0)
		
	def onPlayOnce(self):
		#self.timer = QtCore.QTimer(self)
		#self.timer.timeout.connect(self.onNextFrame)
		self.delay = 10
		self.dataset.selectSerieIndex(0)
		QtCore.QTimer.singleShot(self.delay, self.onNextFrame);
		
	def onNextFrame(self, *args):
		#print args
		step = 15
		next = self.serieIndex +step
		if next >= self.nSlices:
			next = self.nSlices-1
		self.dataset.selectSerieIndex(next)
		if self.serieIndex < self.nSlices-1 : # not last frame
			QtCore.QTimer.singleShot(self.delay, self.onNextFrame);
			
			
	def onSerieIndex(self, index):
		if index != self.dataset.selected_serie_index: # avoid unneeded event
			self.dataset.selectSerieIndex(index)
		
	def onSerieIndexSelect(self, serie_index):
		if serie_index != self.serieIndex: # avoid unneeded event
			self.serieIndex = serie_index
			self.seriesbox.setCurrentIndex(self.serieIndex)
		else:
			self.serieIndex = serie_index
		self.compute()
		self.plot()
		
	def getColumnNames(self):
		return self.__dict__['dataset'].rank1names
	
	def getColumnDict(self):
		return self.dataset.rank1s

	def getdatax(self):
		return self.datax[self.serieIndex,slice(*self.dataset.current_slice)]
	def getdatay(self):
		return self.datay[self.serieIndex,slice(*self.dataset.current_slice)]

class ScatterPlotDialog_old(QtGui.QDialog):
	def __init__(self, parent, dataset, xname=None, yname=None, width=5, height=4, dpi=100):
		super(ScatterPlotDialog, self).__init__(parent)
		self.resize(700,700)
		self.dataset = dataset
		
		self.fig = Figure(figsize=(width, height), dpi=dpi)
		self.axes = self.fig.add_subplot(111)
		self.axes.hold(True)
		
		print "scatter plot", xname, yname
		self.currentXIndex = 0 if xname is None else self.dataset.column_names.index(xname)
		self.currentYIndex = 1 if yname is None else self.dataset.column_names.index(yname) 
		print "scatter plot", self.currentXIndex, self.currentYIndex
		
		x = self.dataset.column_names[self.currentXIndex]
		y = self.dataset.column_names[self.currentYIndex]
		self.datax = self.dataset.columns[x][slice(*self.dataset.current_slice)]
		self.datay = self.dataset.columns[y][slice(*self.dataset.current_slice)]
		
		
		
		self.canvas =  FigureCanvas(self.fig)
		self.canvas.setParent(self)
		
		self.selected_row = None

		self.mask = None
		self.plot()
		FigureCanvas.setSizePolicy(self,
									QtGui.QSizePolicy.Expanding,
									QtGui.QSizePolicy.Expanding)
		FigureCanvas.updateGeometry(self)
		
		self.mpl_toolbar = NavigationToolbar(self.canvas, self.axes, self)

		self.boxlist = QtGui.QVBoxLayout(self)
		
		self.form_layout = QtGui.QFormLayout()
		
		self.xname = QtGui.QComboBox(self)
		self.form_layout.addRow('X-axis:', self.xname)
		self.xname.addItems(self.dataset.column_names)
		self.xname.setCurrentIndex(self.currentXIndex)
		self.xname.currentIndexChanged.connect(self.onX)
		
		self.yname = QtGui.QComboBox(self)
		self.form_layout.addRow('Y-axis:', self.yname)
		self.yname.addItems(self.dataset.column_names)
		self.yname.setCurrentIndex(self.currentYIndex)
		self.yname.currentIndexChanged.connect(self.onY)
		
		self.boxlist.addWidget(self.canvas, 1)
		self.boxlist.addWidget(self.mpl_toolbar, 1)
		self.boxlist.addLayout(self.form_layout, 0)
		self.setLayout(self.boxlist)
		
		#self.fig.canvas.mpl_connect('button_press_event', self.onclick)
		self.dataset.row_selection_listeners.append(self.onRowSelect)
		import matplotlib.widgets
		#self.lasso = matplotlib.widgets.LassoSelector(self.axes, self.onLassoSelect)
		#self.rectselect = matplotlib.widgets.RectangleSelector(self.axes, self.onLassoSelect)
		#self.spanselect = matplotlib.widgets.SpanSelector(self.axes, self.onLassoSelect, 'horizontal')
		self.dataset.mask_listeners.append(self.onMaskSelect)
		
	def onMaskSelect(self, mask):
		self.mask = mask
		self.plot()

	def set_mask(self, mask):
		self.dataset._set_mask(mask)
		
	def onLassoSelect(self, *args):
		print args
		
	def press_select_point(self, event):
		print 'button=%d, x=%d, y=%d, xdata=%f, ydata=%f'% (event.button, event.x, event.y, event.xdata, event.ydata)
		px, py = event.xdata, event.ydata
		x = self.dataset.column_names[self.currentXIndex]
		self.datax = self.dataset.columns[x][slice(*self.dataset.current_slice)]
		y = self.dataset.column_names[self.currentYIndex]
		self.datay = self.dataset.columns[y][slice(*self.dataset.current_slice)]
		#print self.datax, self.datay
		selected_row = find_nearest_index(self.datax, self.datay, px, py)
		print "nearest row", selected_row, self.datax[selected_row], self.datay[selected_row]
		self.dataset.selectRow(selected_row)
		
	def onRowSelect(self, row):
		print "row selected", row
		self.selected_row = row
		x = self.dataset.column_names[self.currentXIndex]
		self.datax = self.dataset.columns[x][slice(*self.dataset.current_slice)]
		y = self.dataset.column_names[self.currentYIndex]
		self.datay = self.dataset.columns[y][slice(*self.dataset.current_slice)]
		self.plot()
		
	def onX(self, index):
		print "x changed", index
		self.currentXIndex = index
		x = self.dataset.column_names[self.currentXIndex]
		self.datax = self.dataset.columns[x][slice(*self.dataset.current_slice)]
		self.plot()
	
	def onY(self, index):
		print "y changed", index
		self.currentYIndex = index
		y = self.dataset.column_names[self.currentYIndex]
		self.datay = self.dataset.columns[y][slice(*self.dataset.current_slice)]
		self.plot()
		


	def plot(self):
		self.axes.cla()
		#x = np.arange(0,10,0.01)
		#y = x**x
		
		#x = self.dataset.column_names[self.currentXIndex]
		#y = self.dataset.column_names[self.currentYIndex]

		dataxsel, dataysel = None, None
		datax = self.datax 
		datay = self.datay
		if self.mask is not None:
			#print self.mask
			#print "sum of mask", sum(self.mask)
			dataxsel = datax[self.mask]
			dataysel = datay[self.mask]
			#print dataxsel
			#print len(dataxsel)
		
		ranges = np.nanmin(datax), np.nanmax(datax), np.nanmin(datay), np.nanmax(datay)
		t0 = time.time()
		if 1:
			parts = 20
			Iparts = np.zeros((parts, 128, 128))
			Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
			@parallelize(cores=QtCore.QThread.idealThreadCount())
			def histo2d_par(part):
				N = len(datax)
				i1 = (N / parts) * part
				i2 = (N / parts) * (part+1)
				#print i1, i2,datax[i1:i2],datay[i1:i2], Iparts[part], ranges
				histo2d(datax[i1:i2], datay[i1:i2], Iparts[part], *ranges)
				#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			histo2d_par(range(parts))
			I = np.sum(Iparts, axis=0)
		else:
			I = np.zeros((parts, 128, 128), dtype=np.int32)
			histo2d(datax, datay, Iparts, np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			I = np.sum(I, axis=0)
		print "it took", time.time()-t0
		if dataxsel is not None:
			parts = 20
			Iparts = np.zeros((parts, 128, 128))
			Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
			@parallelize(cores=QtCore.QThread.idealThreadCount())
			def histo2d_par(part):
				N = len(dataxsel)
				i1 = (N / parts) * part
				i2 = (N / parts) * (part+1)
				#print i1, i2,dataxsel[i1:i2],dataysel[i1:i2], Iparts[part], ranges
				histo2d(dataxsel[i1:i2], dataysel[i1:i2], Iparts[part], *ranges)
				#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			histo2d_par(range(parts))
			Is = np.sum(Iparts, axis=0)
		
		#I, x, y = np.histogram2d(self.dataset.columns[x], self.dataset.columns[y], bins=128)
		#print res
		#I = res
		
		self.axes.imshow(np.log10(I.T), origin="lower", extent=ranges, alpha=1 if dataxsel is None else 0.4)
		if dataxsel is not None:
			self.axes.imshow(np.log10(Is.T), origin="lower", extent=ranges, alpha=1)
		#self.axes.imshow((I), origin="lower", extent=ranges)
		self.axes.set_aspect('auto')
		if self.selected_row is not None:
			#self.axes.autoscale(False)
			x, y = self.datax[self.selected_row],  self.datay[self.selected_row]
			print "drawing selected point at", x, y
			self.axes.scatter([x], [y], color='red') #, scalex=False, scaley=False)
		#if dataxsel is not None:
		#	self.axes.scatter(dataxsel, dataysel)
		self.canvas.draw()
		
		
class SerieSlicePlotDialog_(QtGui.QDialog):
	def __init__(self, parent, data, width=5, height=4, dpi=100):
		super(SerieSlicePlotDialog, self).__init__(parent)
		self.resize(500,500)
		self.data = data
		
		self.fig = Figure(figsize=(width, height), dpi=dpi)
		self.axes = self.fig.add_subplot(111)
		self.axes.hold(True)
		
		self.currentXIndex = 0
		self.currentYIndex = 1
		
		self.serieIndex = 0
		
		x = self.data.rank1names[self.currentXIndex]
		y = self.data.rank1names[self.currentYIndex]
		self.datax = self.data.rank1s[x][self.serieIndex,slice(*self.data.current_slice)]
		self.datay = self.data.rank1s[y][self.serieIndex,slice(*self.data.current_slice)]
		
		
		
		self.canvas =  FigureCanvas(self.fig)
		self.canvas.setParent(self)
		
		self.selected_row = None

		self.plot()
		FigureCanvas.setSizePolicy(self,
									QtGui.QSizePolicy.Expanding,
									QtGui.QSizePolicy.Expanding)
		FigureCanvas.updateGeometry(self)

		self.boxlist = QtGui.QVBoxLayout(self)
		
		self.form_layout = QtGui.QFormLayout()
		
		self.xname = QtGui.QComboBox(self)
		self.form_layout.addRow('X-axis:', self.xname)
		self.xname.addItems(self.data.rank1names)
		self.xname.currentIndexChanged.connect(self.onX)
		
		self.yname = QtGui.QComboBox(self)
		self.form_layout.addRow('Y-axis:', self.yname)
		self.yname.addItems(self.data.rank1names)
		self.yname.setCurrentIndex(1)
		self.yname.currentIndexChanged.connect(self.onY)
		
		self.boxlist.addWidget(self.canvas, 1)
		self.boxlist.addLayout(self.form_layout, 0)
		self.setLayout(self.boxlist)
		
		self.fig.canvas.mpl_connect('button_press_event', self.onclick)
		self.data.row_selection_listeners.append(self.onRowSelect)
		self.data.serie_index_selection_listeners.append(self.onSerieIndexSelect)
		
	def onclick(self, event):
		print 'button=%d, x=%d, y=%d, xdata=%f, ydata=%f'% (event.button, event.x, event.y, event.xdata, event.ydata)
		x, y = event.xdata, event.ydata
		selected_row = find_nearest_index(self.datax, self.datay, x, y)
		print "nearest row", selected_row, self.datax[selected_row], self.datay[selected_row]
		self.data.selectRow(selected_row)
		
	def onRowSelect(self, row):
		print "row selected", row
		self.selected_row = row
		self.plot()
		
	def onSerieIndexSelect(self, serie_index):
		print "series index selected", serie_index
		self.serieIndex = serie_index
		x = self.data.rank1names[self.currentXIndex]
		y = self.data.rank1names[self.currentYIndex]
		self.datax = self.data.rank1s[x][self.serieIndex,slice(*self.data.current_slice)]
		self.datay = self.data.rank1s[y][self.serieIndex,slice(*self.data.current_slice)]
		
		self.plot()
		
	def onX(self, index):
		print "x changed", index
		self.currentXIndex = index
		x = self.data.rank1names[self.currentXIndex]
		self.datax = self.data.rank1s[x][self.serieIndex,slice(*self.data.current_slice)]
		self.plot()
	
	def onY(self, index):
		print "y changed", index
		self.currentYIndex = index
		y = self.data.rank1names[self.currentYIndex]
		y = self.data.rank1names[self.currentYIndex]
		self.datay = self.data.rank1s[y][self.serieIndex,slice(*self.data.current_slice)]
		self.plot()
		


	def plot(self):
		self.axes.cla()
		#x = np.arange(0,10,0.01)
		#y = x**x
		
		#x = self.data.column_names[self.currentXIndex]
		#y = self.data.column_names[self.currentYIndex]

		datax = self.datax 
		datay = self.datay 
		ranges = np.nanmin(datax), np.nanmax(datax), np.nanmin(datay), np.nanmax(datay)
		t0 = time.time()
		if 1:
			parts = 20
			Iparts = np.zeros((parts, 128, 128))
			Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
			@parallelize(cores=QtCore.QThread.idealThreadCount())
			def histo2d_par(part):
				N = self.data._length
				i1 = (N / parts) * part
				i2 = (N / parts) * (part+1)
				#print i1, i2
				histo2d(datax[i1:i2], datay[i1:i2], Iparts[part], *ranges)
				#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			histo2d_par(range(parts))
			I = np.sum(Iparts, axis=0)
		else:
			I = np.zeros((parts, 128, 128), dtype=np.int32)
			histo2d(datax, datay, Iparts, np.min(datax), np.max(datax), np.min(datay), np.max(datay))
			I = np.sum(I, axis=0)
		print "it took", time.time()-t0
		
		#I, x, y = np.histogram2d(self.data.columns[x], self.data.columns[y], bins=128)
		#print res
		#I = res
		
		self.axes.imshow(np.log10(I.T), origin="lower", extent=ranges)
		#self.axes.imshow((I), origin="lower", extent=ranges)
		self.axes.set_aspect('auto')
		if self.selected_row is not None:
			#self.axes.autoscale(False)
			x, y = self.datax[self.selected_row],  self.datay[self.selected_row]
			print "drawing selected point at", x, y
			self.axes.scatter([x], [y], color='red') #, scalex=False, scaley=False)
		self.canvas.draw()		

class ScatterSeries2dPlotDialog(QtGui.QDialog):
	def __init__(self, parent, data, width=5, height=4, dpi=100):
		super(ScatterSeries2dPlotDialog, self).__init__(parent)
		self.resize(500,500)
		self.data = data
		
		self.fig = Figure(figsize=(width, height), dpi=dpi)
		self.axes = self.fig.add_subplot(111)
		self.axes.hold(True)
		
		self.currentXIndex = 0
		self.currentYIndex = 1
		
		x = self.data.rank1names[self.currentXIndex]
		y = self.data.rank1names[self.currentYIndex]
		self.selected_serie_index = None
		
		xseries = self.data.rank1s[x]
		yseries = self.data.rank1s[y]
		
		self.datax = xseries[:,0 if self.data.selected_row_index is None else self.data.selected_row_index]
		self.datay = yseries[:,0 if self.data.selected_row_index is None else self.data.selected_row_index]

		
		self.canvas =  FigureCanvas(self.fig)
		self.canvas.setParent(self)

		self.plot()
		FigureCanvas.setSizePolicy(self,
									QtGui.QSizePolicy.Expanding,
									QtGui.QSizePolicy.Expanding)
		FigureCanvas.updateGeometry(self)

		self.boxlist = QtGui.QVBoxLayout(self)
		
		self.form_layout = QtGui.QFormLayout()
		
		self.xname = QtGui.QComboBox(self)
		self.form_layout.addRow('X-axis:', self.xname)
		self.xname.addItems(self.data.rank1names)
		self.xname.currentIndexChanged.connect(self.onX)
		
		self.yname = QtGui.QComboBox(self)
		self.form_layout.addRow('Y-axis:', self.yname)
		self.yname.addItems(self.data.rank1names)
		self.yname.setCurrentIndex(1)
		self.yname.currentIndexChanged.connect(self.onY)
		
		self.boxlist.addWidget(self.canvas, 1)
		self.boxlist.addLayout(self.form_layout, 0)
		self.setLayout(self.boxlist)
		self.data.row_selection_listeners.append(self.onRowSelect)
		
		self.fig.canvas.mpl_connect('button_press_event', self.onclick)
		self.data.row_selection_listeners.append(self.onRowSelect)
		self.data.serie_index_selection_listeners.append(self.onSerieSelect)
		
	def onclick(self, event):
		print 'button=%d, x=%d, y=%d, xdata=%f, ydata=%f'% (event.button, event.x, event.y, event.xdata, event.ydata)
		x, y = event.xdata, event.ydata
		selected_index = find_nearest_index(self.datax, self.datay, x, y)
		print "nearest selected_index", selected_index, self.datax[selected_index], self.datay[selected_index]
		self.data.selectSerieIndex(selected_index)
		
	def onSerieSelect(self, serie_index):
		self.selected_serie_index = serie_index
		self.plot()
		
	def onRowSelect(self, row):
		x = self.data.rank1names[self.currentXIndex]
		y = self.data.rank1names[self.currentYIndex]
		xseries = self.data.rank1s[x]
		yseries = self.data.rank1s[y]
		self.datax = xseries[:,self.data.selected_row_index]
		self.datay = yseries[:,self.data.selected_row_index]
		self.plot()
		
	def onX(self, index):
		print "x changed", index
		self.currentXIndex = index
		x = self.data.rank1names[self.currentXIndex]
		xseries = self.data.rank1s[x]
		self.datax = xseries[:,self.data.selected_row_index]

		self.plot()
	
	def onY(self, index):
		print "y changed", index
		self.currentYIndex = index
		y = self.data.rank1names[self.currentYIndex]
		yseries = self.data.rank1s[y]
		self.datay = yseries[:,self.data.selected_row_index]
		self.plot()


	def plot(self):
		self.axes.cla()
		#x = np.arange(0,10,0.01)
		#y = x**x
		

		self.axes.plot(self.datax, self.datay)
		self.axes.scatter(self.datax, self.datay)
		#self.axes.imshow(xseries, origin="lower") #, extent=ranges)
		#self.axes.set_aspect('auto')
		if 0:
			#datax = self.data.columns[x][slice(*self.data.current_slice)]
			#datay = self.data.columns[y][slice(*self.data.current_slice)]
			#ranges = np.nanmin(datax), np.nanmax(datax), np.nanmin(datay), np.nanmax(datay)
			t0 = time.time()
			if 1:
				parts = 20
				Iparts = np.zeros((parts, 128, 128))
				Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
				@parallelize(cores=QtCore.QThread.idealThreadCount())
				def histo2d_par(part):
					N = self.data._length
					i1 = (N / parts) * part
					i2 = (N / parts) * (part+1)
					#print i1, i2
					histo2d(datax[i1:i2], datay[i1:i2], Iparts[part], *ranges)
					#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
				histo2d_par(range(parts))
				I = np.sum(Iparts, axis=0)
			else:
				I = np.zeros((parts, 128, 128), dtype=np.int32)
				histo2d(datax, datay, Iparts, np.min(datax), np.max(datax), np.min(datay), np.max(datay))
				I = np.sum(I, axis=0)
			print "it took", time.time()-t0
			
			#I, x, y = np.histogram2d(self.data.columns[x], self.data.columns[y], bins=128)
			#print res
			#I = res
			
			#self.axes.imshow(np.log10(I), origin="lower", extent=ranges)
			self.axes.imshow((I), origin="lower", extent=ranges)
			self.axes.set_aspect('auto')
		if self.selected_serie_index is not None:
			#self.axes.autoscale(False)
			x, y = self.datax[self.selected_serie_index],  self.datay[self.selected_serie_index]
			print "drawing selected point at", x, y
			self.axes.scatter([x], [y], color='red') #, scalex=False, scaley=False)
		self.canvas.draw()


class ScatterSeries1dPlotDialog(QtGui.QDialog):
	def __init__(self, parent, data, width=5, height=4, dpi=100):
		super(ScatterSeries1dPlotDialog, self).__init__(parent)
		self.resize(500,500)
		self.data = data
		
		self.fig = Figure(figsize=(width, height), dpi=dpi)
		self.axes = self.fig.add_subplot(111)
		self.axes.hold(True)
		
		self.currentYIndex = 1
		self.selected_serie_index = None
		y = self.data.rank1names[self.currentYIndex]
		yseries = self.data.rank1s[y]
		self.datay = yseries[:,0 if self.data.selected_row_index is None else self.data.selected_row_index]
		
		
		self.canvas =  FigureCanvas(self.fig)
		self.canvas.setParent(self)

		self.plot()
		FigureCanvas.setSizePolicy(self,
									QtGui.QSizePolicy.Expanding,
									QtGui.QSizePolicy.Expanding)
		FigureCanvas.updateGeometry(self)

		self.boxlist = QtGui.QVBoxLayout(self)
		
		self.form_layout = QtGui.QFormLayout()
		
		self.yname = QtGui.QComboBox(self)
		self.form_layout.addRow('Y-axis:', self.yname)
		self.yname.addItems(self.data.rank1names)
		self.yname.setCurrentIndex(1)
		self.yname.currentIndexChanged.connect(self.onY)
		
		self.boxlist.addWidget(self.canvas, 1)
		self.boxlist.addLayout(self.form_layout, 0)
		self.setLayout(self.boxlist)
		self.fig.canvas.mpl_connect('button_press_event', self.onclick)
		self.data.row_selection_listeners.append(self.onRowSelect)
		self.data.serie_index_selection_listeners.append(self.onSerieIndexSelect)

	def onclick(self, event):
		print 'button=%d, x=%d, y=%d, xdata=%f, ydata=%f'% (event.button, event.x, event.y, event.xdata, event.ydata)
		x, y = event.xdata, event.ydata
		##selected_index = find_nearest_index1d(self.datay, y)
		selected_index = int(x)
		print "nearest selected_index", selected_index, self.datay[selected_index]
		self.data.selectSerieIndex(selected_index)
		
	def onRowSelect(self, row):
		y = self.data.rank1names[self.currentYIndex]
		yseries = self.data.rank1s[y]
		self.datay = yseries[:,self.data.selected_row_index]
		self.plot()
		
	def onSerieIndexSelect(self, serie_index):
		self.selected_serie_index = serie_index
		self.plot()
		
	def onY(self, index):
		print "y changed", index
		self.currentYIndex = index
		y = self.data.rank1names[self.currentYIndex]
		yseries = self.data.rank1s[y]
		self.datay = yseries[:,0 if self.data.selected_row_index is None else self.data.selected_row_index]
		print ">", self.datay.shape, self.data.selected_row_index
		print yseries.shape
		print yseries[:,self.data.selected_row_index].shape
		self.plot()


	def plot(self):
		self.axes.cla()
		#x = np.arange(0,10,0.01)
		#y = x**x
		


		self.axes.plot(self.datay)
		#self.axes.imshow(xseries, origin="lower") #, extent=ranges)
		#self.axes.set_aspect('auto')
		if 0:
			#datax = self.data.columns[x][slice(*self.data.current_slice)]
			#datay = self.data.columns[y][slice(*self.data.current_slice)]
			#ranges = np.nanmin(datax), np.nanmax(datax), np.nanmin(datay), np.nanmax(datay)
			t0 = time.time()
			if 1:
				parts = 20
				Iparts = np.zeros((parts, 128, 128))
				Iparts = mab.utils.numpy.mmapzeros((parts, 128, 128), dtype=np.int32)
				@parallelize(cores=QtCore.QThread.idealThreadCount())
				def histo2d_par(part):
					N = self.data._length
					i1 = (N / parts) * part
					i2 = (N / parts) * (part+1)
					#print i1, i2
					histo2d(datax[i1:i2], datay[i1:i2], Iparts[part], *ranges)
					#histo2d(datax[part::parts], datay[part::parts], Iparts[part], np.min(datax), np.max(datax), np.min(datay), np.max(datay))
				histo2d_par(range(parts))
				I = np.sum(Iparts, axis=0)
			else:
				I = np.zeros((parts, 128, 128), dtype=np.int32)
				histo2d(datax, datay, Iparts, np.min(datax), np.max(datax), np.min(datay), np.max(datay))
				I = np.sum(I, axis=0)
			print "it took", time.time()-t0
			
			#I, x, y = np.histogram2d(self.data.columns[x], self.data.columns[y], bins=128)
			#print res
			#I = res
			
			#self.axes.imshow(np.log10(I), origin="lower", extent=ranges)
			self.axes.imshow((I), origin="lower", extent=ranges)
			self.axes.set_aspect('auto')
		if self.selected_serie_index is not None:
			x, y = self.selected_serie_index, self.datay[self.selected_serie_index]
			print "drawing selected point at", x, y
			self.axes.scatter([x], [y], color='red') #, scalex=False, scaley=False)
			
		self.canvas.draw()



class Example(QtGui.QMainWindow):
	def __init__(self):
		super(Example, self).__init__()
		
		self.initUI()
		
	def initUI(self):
		
		QtGui.QToolTip.setFont(QtGui.QFont('SansSerif', 10))
		
		self.setToolTip('This is a <b>QWidget</b> widget')
		
		
		if 0:
			qbtn = QtGui.QPushButton('Quit', self)
			qbtn.clicked.connect(QtCore.QCoreApplication.instance().quit)
			qbtn.resize(qbtn.sizeHint())
			qbtn.move(150, 150) 
			
			btn = QtGui.QPushButton('Button', self)
			btn.setToolTip('This is a <b>QPushButton</b> widget')
			btn.resize(btn.sizeHint())
			btn.move(50, 50)       
		
		#self.setGeometry(300, 300, 250, 150)
		self.resize(700,500)
		self.center()
		self.setWindowTitle('vaex samp test')
		#self.statusBar().showMessage('Ready')
		
		
		
		self.left = QtGui.QFrame(self)
		self.left.setFrameShape(QtGui.QFrame.StyledPanel)
		
		self.right = MainPanel(self) #QtGui.QFrame(self)
		self.right.setFrameShape(QtGui.QFrame.StyledPanel)
		
		self.splitter = QtGui.QSplitter(QtCore.Qt.Horizontal)
		self.splitter.addWidget(self.left)
		self.splitter.addWidget(self.right)
		
		#self.hbox = QtGui.QHBoxLayout(self)
		#self.hbox.addWidget(self.splitter)
		self.setCentralWidget(self.splitter)
		#self.setLayout(self.hbox)

        
        
		self.list = DataList(self.left)
		self.list.setMinimumWidth(300)
		#self.list.resize(30
		
		self.boxlist = QtGui.QHBoxLayout(self)
		self.boxlist.addWidget(self.list)
		self.left.setLayout(self.boxlist)
		
		#self.list.currentItemChanged.connect(self.infoPanel.onDataSelected)
		self.list.currentItemChanged.connect(self.right.onDataSelected)
		self.list.testfill()
		#self.list.itemSelectionChanged.connect(self.right.onDataSelected)
		
		
		
		
		exitAction = QtGui.QAction(QtGui.QIcon('icons/png/24x24/actions/application-exit-2.png'), '&Exit', self)        
		exitAction.setShortcut('Ctrl+Q')
		exitAction.setStatusTip('Exit application')
		exitAction.triggered.connect(QtGui.qApp.quit)
		
		menubar = self.menuBar()
		fileMenu = menubar.addMenu('&File')
		fileMenu.addAction(exitAction)
		
		#self.toolbar = self.addToolBar('Exit')
		#self.toolbar.addAction(exitAction)
		
        
		self.show()
		
		
	def center(self):
		
		qr = self.frameGeometry()
		cp = QtGui.QDesktopWidget().availableGeometry().center()
		qr.moveCenter(cp)
		self.move(qr.topLeft())		
		
	def _closeEvent(self, event):
		
		reply = QtGui.QMessageBox.question(self, 'Message',
			"Are you sure to quit?", QtGui.QMessageBox.Yes | 
			QtGui.QMessageBox.No, QtGui.QMessageBox.No)

		if reply == QtGui.QMessageBox.Yes:
			event.accept()
		else:
			event.ignore()               
        

def main():
	app = QtGui.QApplication(sys.argv)
	ex = Example()
	ex.raise_()
	#w = QtGui.QWidget()
	#w.resize(250, 150)
	#w.move(300, 300)
	#w.setWindowTitle('Simple')
	#w.show()

	sys.exit(app.exec_())


if __name__ == '__main__':
    main()