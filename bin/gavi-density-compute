#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import time
import os

from optparse import OptionParser
import subspacefind
import h5py
import numpy as np
import itertools
parser = OptionParser()
import mmap

parser.add_option("-n", "--name",
                  help="dataset name [default=%default]", default="data", type=str)
parser.add_option("-a", "--all", action="store_true", default=False, help="compute all densities")
parser.add_option("-l", "--link", action="store_true", default=False, help="link to original datatsets")
parser.add_option("-s", "--shuffled", action="store_true", default=False, help="include shuffled density")
parser.add_option("-m", "--mmap", action="store_true", default=False, help="do memory mapping")
parser.add_option("-d", "--dimensions", default="12", help="which dimensions: options are 1 2 3 or 12 13 etc [default=%default]", type=str)
parser.add_option("-o", "--output",
                  help="output hdf5 file, default the same as input", default=None, type=str)
(options, args) = parser.parse_args()

#h5file = h5py.File(args[0], "r", driver="core")
h5filename = os.path.abspath(args[0])
if options.output is None:
	h5filename_output = h5filename
else:
	h5filename_output = os.path.abspath(options.output)
	
print "opening:", h5filename
if h5filename == h5filename_output:
	h5file = h5py.File(h5filename) #, driver="core")
	h5file_output = h5file # h5py.File(h5filename_output)
	data = h5file[options.name]
else:
	h5file = h5py.File(h5filename, "r")#, driver="core")
	h5file_output = h5py.File(h5filename_output) #, driver="core")
if options.name not in h5file:
	print "doesn't exist", options.name
	sys.exit(1)
	
data = h5file["data"]

mmapped_data = {}


Nkde = 64*2
Nkde = 512
Nkde = 64*2
Nkde3d = 64 #128


class Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        print 'Elapsed: %s' % (time.time() - self.tstart)
        
from numba import jit
import numba
import math
print numba.__version__

@jit('i4[:](f8[:])')
def histo(data, bincount, datamin, datamax):
	length = len(data)
	counts = np.zeros(bincount, dtype=np.int32)
	#return bindata#
	for i in range(length):
		binNo = int(math.floor( ((data[i] - datamin) / (float(datamax) - datamin)) * float(bincount)))
		if binNo >= 0 and binNo < bincount:
			counts[binNo] += 1
		elif binNo == bincount:
			counts[binNo-1] += 1
	#step = float(datamax-datamin)/bincount
	#return numpy.arange(datamin, datamax+step/2, step), binData
	return counts
	#for i in range(N):
	#	offset = data[
		
from numpy import arange, zeros
@jit('c8(f8[:])', nopython=True)
def _minmax(data):
	#ar = np.zeros(2, dtype=np.float64)
	length = len(data)
	xmin = data[0]
	xmax = data[0]
	for i in range(length):
		#xmin = data[i] if data[i] < xmin else xmin
		#xmax = data[i] if data[i] > xmax else xmax
		if data[i] < xmin:
			xmin = data[i]
		if data[i] > xmax:
			xmax = data[i]
	#ar[0] = xmin
	#ar[1] = xmax
	#return ar
	return xmin + 1j*xmax
	
def minmax(data):
	z = _minmax(data)
	return z.real, z.imag
        
if options.mmap:
	print "using memory mapping"
	#h5file.close()
	print h5filename
	f = file(h5filename, "r")
	fileno = f.fileno()
	print f
	print fileno
	mapping = mmap.mmap(fileno, 0, prot=mmap.PROT_READ)
	#import pdb
	#pdb.set_trace()
	#mmap = mmap.
	
	for column_name in data:
		column = data[column_name]
		print `column`
		# offset within file
		offset = column.id.get_offset() 
		
		#sizeof_type = numpy.zeros(1, dtype=column.dtype).nbytes
		mmapped_array = np.frombuffer(mapping, dtype=column.dtype, count=len(column), offset=offset)
		#	ar = ar.reshape(shape)
		mmapped_data[column_name] = mmapped_array
	md = mmapped_data
	if 1:
		with Timer('reading'):
			x = md["x"]
			print "len x =", len(x)
			y = md["y"]
			#print "len x =", len(y)
		print x #, y
		with Timer('min/max'):
			#if 1:
			minx, maxx = np.min(x), np.max(x)
			#minx, maxx = minmax(x)
			#miny, maxy = np.min(y), np.max(y)
			print "min x =", minx
			#print "min x =", miny
			minima = [minx]#, miny]
			maxima = [maxx]#, maxy]
			k = 0
		
		with Timer('histogram'):
			#h = np.histogram(x, bins=Nkde, range=(minx, maxx))
			counts = histo(x, Nkde, minx, maxx)
			import matplotlib.pyplot as plt
			#plt.plot(counts)
			#plt.show()
			#import kaplot
			#kaplot.graph(counts)
			#kaplot.draw()
		sys.exit(0)
		with Timer('kde'):
			map = subspacefind.DensityMap1d(minx, maxx, Nkde);
			#mask = ~np.isnan(columns_data[k])
			N = len(x)
			sx1 = 2.0*(maxx-minx)/N**(1./3);
			#print "bla2"
			#print minima[k], maxima[k]	
			if maxima[k] == minima[k]:
					maxima[k] = minima[k] + 1
			print "calculating gmean"
			prob = x * 0
			gmean = map.comp_data_probs(sx1, x, prob);
			print "gmean", gmean, minima[k], maxima[k]#n
			print "calculating density..."
			map.adaptive_density(sx1, gmean, x, prob);
			print "calculating density done"
		image = np.zeros((Nkde,), dtype=np.float64)
		map.fill(image)
	import pdb
	pdb.set_trace()
	sys.exit(0)
	
	
		
		

def kde(column_names, data, h5density):
	columns = [data[k] for k in column_names]
	if options.mmap:
		mmapped_columns = [data[k] for k in column_names]
		columns_data = mmapped_columns
	else:
		columns_data = columns
	minima = [column.attrs["minimum"] for column in columns]
	maxima = [column.attrs["maximum"] for column in columns]
	dimension = len(columns)
	N = len(columns_data[0])
	for i, column in enumerate(columns[1:]):
		if len(column) != N:
			print "column %d contains %d entry, while first has %d" % (i+2, len(column), N)
			sys.exit(1)

	prob = np.zeros(N, dtype=np.float64)

	if dimension == 1:
		k = 0
		#print "bla1", minima[k], maxima[k], Nkde
		map = subspacefind.DensityMap1d(minima[k], maxima[k], Nkde);
		#print "bla1b"
		#dsa
		mask = ~np.isnan(columns_data[k])
		sx1 = 2.0*(maxima[k]-minima[k])/N**(1./3);
		#print "bla2"
		print minima[k], maxima[k]	
		if maxima[k] == minima[k]:
				maxima[k] = minima[k] + 1
		gmean = map.comp_data_probs(sx1, columns_data[k], prob);
		print gmean, minima[k], maxima[k]#n
		map.adaptive_density(sx1, gmean, columns_data[k], prob);
		image = np.zeros((Nkde,), dtype=np.float64)
		map.fill(image)
		
		basename = "density1d-%s" % tuple(column_names)
		#filename = basename + ".pgm"
		#print "writing out", `filename`
		#map.pgm_write(str(filename))
		
		
		h5group = h5density.require_group(column_names[0])
		if "density" in h5group:
			del h5group["density"]
		h5group.attrs.modify("min", minima[k])
		h5group.attrs.modify("max", maxima[k])
		h5group.attrs.modify("column1_name", str(column_names[0]))
		h5group.create_dataset("density", data=image)

		if options.link:
			if h5file == h5file_output:
				# create a hard link
				h5group.attrs.modify("column1", columns[0])
			else:
				#import pdb
				#pdb.set_trace()
				if "column1" in h5group.keys():
					print "remove column1"
					del h5group["column1"]
				h5group["column1"] = h5py.ExternalLink(h5filename, "/" + options.name + "/" + column_names[0])
		
		if 0:
			print image
			#import kaplot
			kaplot.box()
			kaplot.graph(image)
			kaplot.draw()
			print "done"
		#ImagePGMBinWrite1D(&density1d,"density1.pgm");
	elif dimension == 2:
		k, l = 0, 1
		map = subspacefind.DensityMap2d(
				minima[k]-0.06125*(maxima[k]-minima[k]),
				maxima[k]+0.06125*(maxima[k]-minima[k]),Nkde,
				minima[l]-0.06125*(maxima[l]-minima[l]),
				maxima[l]+0.06125*(maxima[l]-minima[l]),Nkde);
		hscale = 6.0/np.sqrt(N);
		#print columns_data[k].shape
		t0 = time.time()
		gmean = map.comp_data_probs_2d(hscale*(maxima[k]-minima[k]),
					hscale*(maxima[l]-minima[l]),
					columns_data[k], columns_data[l], prob);
		
		t1 = time.time()
		#print "gmean", gmean
		#print "step 1 completed", (t1-t0), "seconds"
		
		map.comp_density_2d (hscale*(maxima[k]-minima[k]), hscale*(maxima[l]-minima[l]), gmean,columns_data[k],columns_data[l],prob);
		t2 = time.time()
		#print "step 2 completed", (t2-t1), "seconds"
		#print "step 1+2 completed", (t2-t0), "seconds"
		#map.pgm_write("density2d-py.pgm")
		basename = "density2d-%s-%s" % tuple(column_names)
		#filename = basename + ".pgm"
		#print "writing out", filename
		#map.pgm_write(str(filename))
		image = np.zeros((Nkde,Nkde), dtype=np.float64)
		map.fill(image)
		#print image.min(), image.max()
		
		h5group = h5density.require_group("-vs-".join(column_names))
		#h5group = h5density
		#for column_name in column_names:
		#	h5group = h5group.require_group(join(column_names[0]))
		if column_names[0] in h5density:
			del h5density[column_names[0]]
		if "density" in h5group:
			del h5group["density"]
		h5group.create_dataset("density", data=image)
		h5group.attrs.modify("min", minima)
		h5group.attrs.modify("max", maxima)
		h5group.attrs.modify("column1_name", column_names[0])
		h5group.attrs.modify("column2_name", column_names[1])
		if options.link:
			if h5file == h5file_output:
				# create a hard link
				h5group.require_group("column1", columns[0])
				h5group.require_group("column2", columns[1])
			else:
				#import pdb
				#pdb.set_trace()
				if "column1" in h5group.keys():
					print "remove column1"
					del h5group["column1"]
				if "column2" in h5group.keys():
					print "remove column2"
					del h5group["column2"]
				h5group["column1"] = h5py.ExternalLink(h5filename, "/" + options.name + "/" + column_names[0])
				h5group["column2"] = h5py.ExternalLink(h5filename, "/" + options.name + "/" + column_names[1])
		
		if options.shuffled:
			map = subspacefind.DensityMap2d(
					minima[k]-0.06125*(maxima[k]-minima[k]),
					maxima[k]+0.06125*(maxima[k]-minima[k]),Nkde,
					minima[l]-0.06125*(maxima[l]-minima[l]),
					maxima[l]+0.06125*(maxima[l]-minima[l]),Nkde);
			hscale = 6.0/np.sqrt(N);
			#print columns_data[k].shape
			def shuffled(column):
				column = np.array(column) * 1. # copy
				np.random.shuffle(column)
				return column
			newcolumns = [columns_data[i] if i == 0 else shuffled(columns_data[i]) for i in range(len(columns))]
			
			t0 = time.time()
			gmean = map.comp_data_probs_2d(hscale*(maxima[k]-minima[k]),
						hscale*(maxima[l]-minima[l]),
						newcolumns_data[k], newcolumns_data[l], prob);
			
			t1 = time.time()
			#print "gmean", gmean
			#print "step 1 completed", (t1-t0), "seconds"
			map.comp_density_2d (hscale*(maxima[k]-minima[k]), hscale*(maxima[l]-minima[l]), gmean,newcolumns_data[k],newcolumns_data[l],prob);
			image2 = np.zeros((Nkde,Nkde), dtype=np.float64)
			map.fill(image2)
			if "density-shuffled" in h5group:
				del h5group["density-shuffled"]
			h5group.create_dataset("density-shuffled", data=image2)
			
		if 0:
			#import matplotlib.pyplot as plt
			I = image
			#I = np.log10(image)
			#I -= I.max()
			#I[I<-4] = -4
			plt.imshow(I, origin="upper", extent=[minima[0], maxima[0], minima[1], maxima[1]])
			plt.xlabel(column_names[0])
			plt.ylabel(column_names[1])
			#plt.title("Quality: %.2f" % quality[i][j])
			plt.savefig(basename +".png", bbox_inches='tight')
			plt.savefig(basename +".eps", bbox_inches='tight')
			
			#			from vtk import *
			dx = 2.0
			grid = vtkStructuredPoints()
			grid.SetOrigin(0, 0, 0) # default values
			grid.SetSpacing(dx, dx, dx)
			grid.SetDimensions(512, 512, 1) # number of points in each direction
			grid.SetNumberOfScalarComponents(1);
			# print grid.GetNumberOfPoints()
			# print grid.GetNumberOfCells()
			#array = vtkDoubleArray()
			#array.SetNumberOfComponents(1) # this is 3 for a vector
			#array.SetNumberOfTuples(grid.GetNumberOfPoints())
			#for i in range(grid.GetNumberOfPoints()):
			#	array.SetValue(i, 1)
			for x in range(512):
				for y in range(512):
					grid.SetScalarComponentFromDouble(x, y, 0, 0, image[x][y])
			#grid.GetPointData().AddArray(array)
			# print grid.GetPointData().GetNumberOfArrays()
			#array.SetName("unit array")	
			vtkfilename = basename + ".vtk"
			print "writing vtk file", vtkfilename
			writer = vtkStructuredPointsWriter()
			writer.SetInput(grid)
			writer.SetFileName(vtkfilename)
			#writer.SetFileDimensionality(2)
			#writer.SetFileTypeToASCII()
			writer.Write()
			
			#plt.show()
	elif dimension == 3:
		#print "3d"
		k, l, m = 0, 1, 2
		map = subspacefind.DensityMap3d(minima[k]-0.06125*(maxima[k]-minima[k]),
			maxima[k]+0.06125*(maxima[k]-minima[k]),Nkde3d,
			minima[l]-0.06125*(maxima[l]-minima[l]),
			maxima[l]+0.06125*(maxima[l]-minima[l]),Nkde3d,
			minima[m]-0.06125*(maxima[m]-minima[m]),
			maxima[m]+0.06125*(maxima[m]-minima[m]),Nkde3d);
			
		hscale = 8.0/np.sqrt(N);
		
		#print columns_data[0]
		gmean = map.comp_data_probs_3d(
						hscale*(maxima[k]-minima[k]),
						hscale*(maxima[l]-minima[l]),
						hscale*(maxima[m]-minima[m]),
						columns_data[k], columns_data[l], columns_data[m], prob);
			
			
		print "gmean 3d", gmean
		map.comp_density_3d(hscale*(maxima[k]-minima[k]),
				hscale*(maxima[l]-minima[l]),
				hscale*(maxima[m]-minima[m]),
				gmean, columns_data[k],columns_data[l],columns_data[m],prob);
		basename = "density3d-%s-%s-%s" % tuple(column_names)
		#avs_filename = basename + ".fld"
		#print "writing", avs_filename
		#map.avs_write(4095, str(avs_filename))
		#print "filling"
		image = np.zeros((Nkde3d, Nkde3d, Nkde3d), dtype=np.float64)
		map.fill(image)
		#print "filling done"
		#sys.exit(0)
		
		
		h5group = h5density.require_group("-vs-".join(column_names))
		#h5group = h5density
		#for column_name in column_names:
		#	h5group = h5group.require_group(join(column_names[0]))
		if column_names[0] in h5density:
			del h5density[column_names[0]]
		if "density" in h5group:
			del h5group["density"]
		h5group.create_dataset("density", data=image)
		h5group.attrs.modify("min", minima)
		h5group.attrs.modify("max", maxima)
		h5group.attrs.modify("column1_name", str(column_names[0]))
		h5group.attrs.modify("column2_name", str(column_names[1]))
		h5group.attrs.modify("column3_name", str(column_names[2]))
		if options.link:
			if h5file == h5file_output:
				# create a hard link
				h5group.attrs.modify("column1", columns_data[0])
				h5group.attrs.modify("column2", columns[1])
				h5group.attrs.modify("column3", columns[2])
			else:
				#import pdb
				#pdb.set_trace()
				if "column1" in h5group.keys():
					print "remove column1"
					del h5group["column1"]
				if "column2" in h5group.keys():
					print "remove column2"
					del h5group["column2"]
				h5group["column1"] = h5py.ExternalLink(h5filename, "/" + options.name + "/" + column_names[0])
				h5group["column2"] = h5py.ExternalLink(h5filename, "/" + options.name + "/" + column_names[1])
				h5group["column3"] = h5py.ExternalLink(h5filename, "/" + options.name + "/" + column_names[3])
				
				
		if options.shuffled:
			map = subspacefind.DensityMap3d(minima[k]-0.06125*(maxima[k]-minima[k]),
				maxima[k]+0.06125*(maxima[k]-minima[k]),Nkde3d,
				minima[l]-0.06125*(maxima[l]-minima[l]),
				maxima[l]+0.06125*(maxima[l]-minima[l]),Nkde3d,
				minima[m]-0.06125*(maxima[m]-minima[m]),
				maxima[m]+0.06125*(maxima[m]-minima[m]),Nkde3d);
			hscale = 8.0/np.sqrt(N);
			
			def shuffled(column):
				column = np.array(column) * 1. # copy
				np.random.shuffle(column)
				return column
			newcolumns = [columns[i] if i == 0 else shuffled(columns[i]) for i in range(len(columns))]
			#print columns[0]
			gmean = map.comp_data_probs_3d(
							hscale*(maxima[k]-minima[k]),
							hscale*(maxima[l]-minima[l]),
							hscale*(maxima[m]-minima[m]),
							newcolumns[k], newcolumns[l], newcolumns[m], prob);
				
			
			print "gmean 3d", gmean
			#print "step 1 completed", (t1-t0), "seconds"
			map.comp_density_3d(hscale*(maxima[k]-minima[k]),
					hscale*(maxima[l]-minima[l]),
					hscale*(maxima[m]-minima[m]),
					gmean, newcolumns[k],newcolumns[l],newcolumns[m],prob);
			
			image2 = np.zeros((Nkde3d,Nkde3d,Nkde3d), dtype=np.float64)
			map.fill(image2)
			if "density-shuffled" in h5group:
				del h5group["density-shuffled"]
			h5group.create_dataset("density-shuffled", data=image2)
				
		
		
		if 0:
			#from vtk import *
			dx = 2.0
			grid = vtkStructuredPoints()
			grid.SetOrigin(0, 0, 0) # default values
			grid.SetSpacing(dx, dx, dx)
			grid.SetDimensions(Nkde3d, Nkde3d, Nkde3d) # number of points in each direction
			grid.SetNumberOfScalarComponents(1);
			for x in range(Nkde3d):
				for y in range(Nkde3d):
					for z in range(Nkde3d):
						grid.SetScalarComponentFromDouble(x, y, z, 0, image[x][y][z])
			#grid.GetPointData().AddArray(array)
			# print grid.GetPointData().GetNumberOfArrays()
			#array.SetName("unit array")	
			vtkfilename = basename + ".vtk"
			print "writing vtk file", vtkfilename
			writer = vtkStructuredPointsWriter()
			writer.SetInput(grid)
			writer.SetFileName(vtkfilename)
			#writer.SetFileDimensionality(2)
			#writer.SetFileTypeToASCII()
			writer.Write()
	else:
		print ">3d not supported"
		sys.exit(1)	


def compute_min_max(data, column_names=None):
	if column_names is None:
		column_names = data.keys()
		
	for column_name in column_names:
		if column_name not in data.keys(): #)
			print column_name, "doesn't exist", data.keys() #"
			sys.exit(0)
		column = data[column_name]
		if "minimum" not in column.attrs:
			print "adding minimum"
			column.attrs["minimum"] = np.min(column)
		if "maximum" not in column.attrs:
			print "adding maximum"
			column.attrs["maximum"] = np.max(column)
#for name in column_names:
if options.all:
	compute_min_max(data)
	column_names = map(str, data.keys())

	
elif (len(args) == 1) and not options.all:
	print "add column names after filename or use -a/--all for all"
	print "possible column names: [%s]:" % " ".join([str(k) for k in data])
	sys.exit(1)
else:
	column_names = map(str, args[1:])

print "columns:", column_names
compute_min_max(data, column_names)

h5densities = h5file_output.require_group("densities")



for d in options.dimensions:
	dim = int(d)
	print "dimension: %d" % dim
	if dim == 3:
		h5densities3d = h5densities.require_group("3d")
		pairs = list(itertools.combinations(column_names, 3))
		i = 0
		for column_names_pair in pairs:
			print "doing 3d kde for", column_names_pair, (i+1), "out of", len(pairs)
			kde(column_names_pair, data, h5densities3d)
			i += 1

	if dim == 1:
		h5densities1d = h5densities.require_group("1d")
		for column_name in column_names:
			print "doing 1d kde for", column_name
			kde([column_name], data, h5densities1d)

	if dim == 2:
		h5densities2d = h5densities.require_group("2d")
		pairs = list(itertools.combinations(column_names, 2))
		print "doing a kde for %d pairs" % len(pairs)
		for column_names_pair in pairs:
			print "doing 2d kde for", column_names_pair
			kde(column_names_pair, data, h5densities2d)


#print columns

#Nx = 50
#Ny = 50
#kde = subspacefind.DensityMap2d(0., 1., Nx, 0., 1., Ny);
